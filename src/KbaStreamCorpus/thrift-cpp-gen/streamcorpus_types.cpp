/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "streamcorpus_types.h"

#include <algorithm>

namespace streamcorpus {

int _kOffsetTypeValues[] = {
  OffsetType::LINES,
  OffsetType::BYTES,
  OffsetType::CHARS
};
const char* _kOffsetTypeNames[] = {
  "LINES",
  "BYTES",
  "CHARS"
};
const std::map<int, const char*> _OffsetType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kOffsetTypeValues, _kOffsetTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEntityTypeValues[] = {
  EntityType::PER,
  EntityType::ORG,
  EntityType::LOC,
  EntityType::TIME,
  EntityType::DATE,
  EntityType::MONEY,
  EntityType::PERCENT,
  EntityType::MISC,
  EntityType::GPE,
  EntityType::FAC,
  EntityType::VEH,
  EntityType::WEA,
  EntityType::phone,
  EntityType::email,
  EntityType::URL
};
const char* _kEntityTypeNames[] = {
  "PER",
  "ORG",
  "LOC",
  "TIME",
  "DATE",
  "MONEY",
  "PERCENT",
  "MISC",
  "GPE",
  "FAC",
  "VEH",
  "WEA",
  "phone",
  "email",
  "URL"
};
const std::map<int, const char*> _EntityType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(15, _kEntityTypeValues, _kEntityTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMentionTypeValues[] = {
  MentionType::NAME,
  MentionType::PRO,
  MentionType::NOM
};
const char* _kMentionTypeNames[] = {
  "NAME",
  "PRO",
  "NOM"
};
const std::map<int, const char*> _MentionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMentionTypeValues, _kMentionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kAttributeTypeValues[] = {
  AttributeType::PER_AGE,
  AttributeType::PER_GENDER
};
const char* _kAttributeTypeNames[] = {
  "PER_AGE",
  "PER_GENDER"
};
const std::map<int, const char*> _AttributeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kAttributeTypeValues, _kAttributeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRelationTypeValues[] = {
  RelationType::PHYS_Located,
  RelationType::PHYS_Near,
  RelationType::PARTWHOLE_Geographical,
  RelationType::PARTWHOLE_Subsidiary,
  RelationType::PARTWHOLE_Artifact,
  RelationType::PERSOC_Business,
  RelationType::PERSOC_Family,
  RelationType::PERSOC_LastingPersonal,
  RelationType::ORGAFF_Employment,
  RelationType::ORGAFF_Ownership,
  RelationType::ORGAFF_Founder,
  RelationType::ORGAFF_StudentAlum,
  RelationType::ORGAFF_SportsAffiliation,
  RelationType::ORGAFF_InvestorShareholder,
  RelationType::ORGAFF_Membership,
  RelationType::ART_UserOwnerInventorManufacturer,
  RelationType::GENAFF_CitizenResidentReligionEthnicity,
  RelationType::GENAFF_OrgLocation,
  RelationType::Business_DeclareBankruptcy,
  RelationType::Business_EndOrg,
  RelationType::Business_MergeOrg,
  RelationType::Business_StartOrg,
  RelationType::Conflict_Attack,
  RelationType::Conflict_Demonstrate,
  RelationType::Contact_PhoneWrite,
  RelationType::Contact_Meet,
  RelationType::Justice_Acquit,
  RelationType::Justice_Appeal,
  RelationType::Justice_ArrestJail,
  RelationType::Justice_ChargeIndict,
  RelationType::Justice_Convict,
  RelationType::Justice_Execute,
  RelationType::Justice_Extradite,
  RelationType::Justice_Fine,
  RelationType::Justice_Pardon,
  RelationType::Justice_ReleaseParole,
  RelationType::Justice_Sentence,
  RelationType::Justice_Sue,
  RelationType::Justice_TrialHearing,
  RelationType::Life_BeBorn,
  RelationType::Life_Die,
  RelationType::Life_Divorce,
  RelationType::Life_Injure,
  RelationType::Life_Marry,
  RelationType::Movement_Transport,
  RelationType::Personnel_Elect,
  RelationType::Personnel_EndPosition,
  RelationType::Personnel_Nominate,
  RelationType::Personnel_StartPosition,
  RelationType::Transaction_TransferMoney,
  RelationType::Transaction_TransferOwnership
};
const char* _kRelationTypeNames[] = {
  "PHYS_Located",
  "PHYS_Near",
  "PARTWHOLE_Geographical",
  "PARTWHOLE_Subsidiary",
  "PARTWHOLE_Artifact",
  "PERSOC_Business",
  "PERSOC_Family",
  "PERSOC_LastingPersonal",
  "ORGAFF_Employment",
  "ORGAFF_Ownership",
  "ORGAFF_Founder",
  "ORGAFF_StudentAlum",
  "ORGAFF_SportsAffiliation",
  "ORGAFF_InvestorShareholder",
  "ORGAFF_Membership",
  "ART_UserOwnerInventorManufacturer",
  "GENAFF_CitizenResidentReligionEthnicity",
  "GENAFF_OrgLocation",
  "Business_DeclareBankruptcy",
  "Business_EndOrg",
  "Business_MergeOrg",
  "Business_StartOrg",
  "Conflict_Attack",
  "Conflict_Demonstrate",
  "Contact_PhoneWrite",
  "Contact_Meet",
  "Justice_Acquit",
  "Justice_Appeal",
  "Justice_ArrestJail",
  "Justice_ChargeIndict",
  "Justice_Convict",
  "Justice_Execute",
  "Justice_Extradite",
  "Justice_Fine",
  "Justice_Pardon",
  "Justice_ReleaseParole",
  "Justice_Sentence",
  "Justice_Sue",
  "Justice_TrialHearing",
  "Life_BeBorn",
  "Life_Die",
  "Life_Divorce",
  "Life_Injure",
  "Life_Marry",
  "Movement_Transport",
  "Personnel_Elect",
  "Personnel_EndPosition",
  "Personnel_Nominate",
  "Personnel_StartPosition",
  "Transaction_TransferMoney",
  "Transaction_TransferOwnership"
};
const std::map<int, const char*> _RelationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(51, _kRelationTypeValues, _kRelationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kVersionsValues[] = {
  Versions::v0_2_0,
  Versions::v0_3_0
};
const char* _kVersionsNames[] = {
  "v0_2_0",
  "v0_3_0"
};
const std::map<int, const char*> _Versions_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kVersionsValues, _kVersionsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* StreamTime::ascii_fingerprint = "DD2684E5F49042C4C07B5348ECFFFD06";
const uint8_t StreamTime::binary_fingerprint[16] = {0xDD,0x26,0x84,0xE5,0xF4,0x90,0x42,0xC4,0xC0,0x7B,0x53,0x48,0xEC,0xFF,0xFD,0x06};

uint32_t StreamTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->epoch_ticks);
          this->__isset.epoch_ticks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zulu_timestamp);
          this->__isset.zulu_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StreamTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StreamTime");

  xfer += oprot->writeFieldBegin("epoch_ticks", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->epoch_ticks);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zulu_timestamp", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->zulu_timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StreamTime &a, StreamTime &b) {
  using ::std::swap;
  swap(a.epoch_ticks, b.epoch_ticks);
  swap(a.zulu_timestamp, b.zulu_timestamp);
  swap(a.__isset, b.__isset);
}

const char* Annotator::ascii_fingerprint = "8D64F3DD69187433CDFC330482190EEE";
const uint8_t Annotator::binary_fingerprint[16] = {0x8D,0x64,0xF3,0xDD,0x69,0x18,0x74,0x33,0xCD,0xFC,0x33,0x04,0x82,0x19,0x0E,0xEE};

uint32_t Annotator::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->annotator_id);
          this->__isset.annotator_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotation_time.read(iprot);
          this->__isset.annotation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Annotator::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Annotator");

  xfer += oprot->writeFieldBegin("annotator_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->annotator_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.annotation_time) {
    xfer += oprot->writeFieldBegin("annotation_time", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->annotation_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Annotator &a, Annotator &b) {
  using ::std::swap;
  swap(a.annotator_id, b.annotator_id);
  swap(a.annotation_time, b.annotation_time);
  swap(a.__isset, b.__isset);
}

const char* Offset::ascii_fingerprint = "A20D4C3BA289AF4627C9FDEC29A1B027";
const uint8_t Offset::binary_fingerprint[16] = {0xA2,0x0D,0x4C,0x3B,0xA2,0x89,0xAF,0x46,0x27,0xC9,0xFD,0xEC,0x29,0xA1,0xB0,0x27};

uint32_t Offset::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (OffsetType::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->xpath);
          this->__isset.xpath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content_form);
          this->__isset.content_form = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Offset::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Offset");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->length);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.xpath) {
    xfer += oprot->writeFieldBegin("xpath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->xpath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.content_form) {
    xfer += oprot->writeFieldBegin("content_form", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->content_form);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Offset &a, Offset &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.first, b.first);
  swap(a.length, b.length);
  swap(a.xpath, b.xpath);
  swap(a.content_form, b.content_form);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* Target::ascii_fingerprint = "8F380763C4E93CCC138A5250BA588978";
const uint8_t Target::binary_fingerprint[16] = {0x8F,0x38,0x07,0x63,0xC4,0xE9,0x3C,0xCC,0x13,0x8A,0x52,0x50,0xBA,0x58,0x89,0x78};

uint32_t Target::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_id);
          this->__isset.target_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->kb_id);
          this->__isset.kb_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kb_snapshot_time.read(iprot);
          this->__isset.kb_snapshot_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Target::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Target");

  xfer += oprot->writeFieldBegin("target_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->target_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.kb_id) {
    xfer += oprot->writeFieldBegin("kb_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->kb_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kb_snapshot_time) {
    xfer += oprot->writeFieldBegin("kb_snapshot_time", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->kb_snapshot_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Target &a, Target &b) {
  using ::std::swap;
  swap(a.target_id, b.target_id);
  swap(a.kb_id, b.kb_id);
  swap(a.kb_snapshot_time, b.kb_snapshot_time);
  swap(a.__isset, b.__isset);
}

const char* Label::ascii_fingerprint = "E98A9E5328B74B3E093000EBAED29699";
const uint8_t Label::binary_fingerprint[16] = {0xE9,0x8A,0x9E,0x53,0x28,0xB7,0x4B,0x3E,0x09,0x30,0x00,0xEB,0xAE,0xD2,0x96,0x99};

uint32_t Label::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotator.read(iprot);
          this->__isset.annotator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->offsets.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              OffsetType::type _key6;
              int32_t ecast8;
              xfer += iprot->readI32(ecast8);
              _key6 = (OffsetType::type)ecast8;
              Offset& _val7 = this->offsets[_key6];
              xfer += _val7.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Label::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Label");

  xfer += oprot->writeFieldBegin("annotator", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->annotator.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offsets) {
    xfer += oprot->writeFieldBegin("offsets", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->offsets.size()));
      std::map<OffsetType::type, Offset> ::const_iterator _iter9;
      for (_iter9 = this->offsets.begin(); _iter9 != this->offsets.end(); ++_iter9)
      {
        xfer += oprot->writeI32((int32_t)_iter9->first);
        xfer += _iter9->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Label &a, Label &b) {
  using ::std::swap;
  swap(a.annotator, b.annotator);
  swap(a.target, b.target);
  swap(a.offsets, b.offsets);
  swap(a.__isset, b.__isset);
}

const char* Token::ascii_fingerprint = "2DBBD09265D2B4E7C44B6341FDA005FB";
const uint8_t Token::binary_fingerprint[16] = {0x2D,0xBB,0xD0,0x92,0x65,0xD2,0xB4,0xE7,0xC4,0x4B,0x63,0x41,0xFD,0xA0,0x05,0xFB};

uint32_t Token::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->token_num);
          this->__isset.token_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->offsets.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _ktype11;
            ::apache::thrift::protocol::TType _vtype12;
            xfer += iprot->readMapBegin(_ktype11, _vtype12, _size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              OffsetType::type _key15;
              int32_t ecast17;
              xfer += iprot->readI32(ecast17);
              _key15 = (OffsetType::type)ecast17;
              Offset& _val16 = this->offsets[_key15];
              xfer += _val16.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sentence_pos);
          this->__isset.sentence_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lemma);
          this->__isset.lemma = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->entity_type = (EntityType::type)ecast18;
          this->__isset.entity_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mention_id);
          this->__isset.mention_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->equiv_id);
          this->__isset.equiv_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parent_id);
          this->__isset.parent_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dependency_path);
          this->__isset.dependency_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->labels.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _ktype20;
            ::apache::thrift::protocol::TType _vtype21;
            xfer += iprot->readMapBegin(_ktype20, _vtype21, _size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              AnnotatorID _key24;
              xfer += iprot->readString(_key24);
              std::vector<Label> & _val25 = this->labels[_key24];
              {
                _val25.clear();
                uint32_t _size26;
                ::apache::thrift::protocol::TType _etype29;
                xfer += iprot->readListBegin(_etype29, _size26);
                _val25.resize(_size26);
                uint32_t _i30;
                for (_i30 = 0; _i30 < _size26; ++_i30)
                {
                  xfer += _val25[_i30].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast31;
          xfer += iprot->readI32(ecast31);
          this->mention_type = (MentionType::type)ecast31;
          this->__isset.mention_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Token::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Token");

  xfer += oprot->writeFieldBegin("token_num", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->token_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->token);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offsets) {
    xfer += oprot->writeFieldBegin("offsets", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->offsets.size()));
      std::map<OffsetType::type, Offset> ::const_iterator _iter32;
      for (_iter32 = this->offsets.begin(); _iter32 != this->offsets.end(); ++_iter32)
      {
        xfer += oprot->writeI32((int32_t)_iter32->first);
        xfer += _iter32->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_pos) {
    xfer += oprot->writeFieldBegin("sentence_pos", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->sentence_pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lemma) {
    xfer += oprot->writeFieldBegin("lemma", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->lemma);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.entity_type) {
    xfer += oprot->writeFieldBegin("entity_type", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->entity_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_id) {
    xfer += oprot->writeFieldBegin("mention_id", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->mention_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.equiv_id) {
    xfer += oprot->writeFieldBegin("equiv_id", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->equiv_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent_id) {
    xfer += oprot->writeFieldBegin("parent_id", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->parent_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dependency_path) {
    xfer += oprot->writeFieldBegin("dependency_path", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->dependency_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->labels.size()));
      std::map<AnnotatorID, std::vector<Label> > ::const_iterator _iter33;
      for (_iter33 = this->labels.begin(); _iter33 != this->labels.end(); ++_iter33)
      {
        xfer += oprot->writeString(_iter33->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter33->second.size()));
          std::vector<Label> ::const_iterator _iter34;
          for (_iter34 = _iter33->second.begin(); _iter34 != _iter33->second.end(); ++_iter34)
          {
            xfer += (*_iter34).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_type) {
    xfer += oprot->writeFieldBegin("mention_type", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32((int32_t)this->mention_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Token &a, Token &b) {
  using ::std::swap;
  swap(a.token_num, b.token_num);
  swap(a.token, b.token);
  swap(a.offsets, b.offsets);
  swap(a.sentence_pos, b.sentence_pos);
  swap(a.lemma, b.lemma);
  swap(a.pos, b.pos);
  swap(a.entity_type, b.entity_type);
  swap(a.mention_id, b.mention_id);
  swap(a.equiv_id, b.equiv_id);
  swap(a.parent_id, b.parent_id);
  swap(a.dependency_path, b.dependency_path);
  swap(a.labels, b.labels);
  swap(a.mention_type, b.mention_type);
  swap(a.__isset, b.__isset);
}

const char* Sentence::ascii_fingerprint = "628F5B4B89BFF2123BB9398A13814BE3";
const uint8_t Sentence::binary_fingerprint[16] = {0x62,0x8F,0x5B,0x4B,0x89,0xBF,0xF2,0x12,0x3B,0xB9,0x39,0x8A,0x13,0x81,0x4B,0xE3};

uint32_t Sentence::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tokens.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->tokens.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->tokens[_i39].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tokens = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->labels.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _ktype41;
            ::apache::thrift::protocol::TType _vtype42;
            xfer += iprot->readMapBegin(_ktype41, _vtype42, _size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              AnnotatorID _key45;
              xfer += iprot->readString(_key45);
              std::vector<Label> & _val46 = this->labels[_key45];
              {
                _val46.clear();
                uint32_t _size47;
                ::apache::thrift::protocol::TType _etype50;
                xfer += iprot->readListBegin(_etype50, _size47);
                _val46.resize(_size47);
                uint32_t _i51;
                for (_i51 = 0; _i51 < _size47; ++_i51)
                {
                  xfer += _val46[_i51].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Sentence::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Sentence");

  xfer += oprot->writeFieldBegin("tokens", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tokens.size()));
    std::vector<Token> ::const_iterator _iter52;
    for (_iter52 = this->tokens.begin(); _iter52 != this->tokens.end(); ++_iter52)
    {
      xfer += (*_iter52).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->labels.size()));
      std::map<AnnotatorID, std::vector<Label> > ::const_iterator _iter53;
      for (_iter53 = this->labels.begin(); _iter53 != this->labels.end(); ++_iter53)
      {
        xfer += oprot->writeString(_iter53->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter53->second.size()));
          std::vector<Label> ::const_iterator _iter54;
          for (_iter54 = _iter53->second.begin(); _iter54 != _iter53->second.end(); ++_iter54)
          {
            xfer += (*_iter54).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Sentence &a, Sentence &b) {
  using ::std::swap;
  swap(a.tokens, b.tokens);
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

const char* Tagging::ascii_fingerprint = "0A0DFB97882FDAD8FD6CF82C36CDF3B0";
const uint8_t Tagging::binary_fingerprint[16] = {0x0A,0x0D,0xFB,0x97,0x88,0x2F,0xDA,0xD8,0xFD,0x6C,0xF8,0x2C,0x36,0xCD,0xF3,0xB0};

uint32_t Tagging::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_id);
          this->__isset.tagger_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->raw_tagging);
          this->__isset.raw_tagging = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_config);
          this->__isset.tagger_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_version);
          this->__isset.tagger_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->generation_time.read(iprot);
          this->__isset.generation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Tagging::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Tagging");

  xfer += oprot->writeFieldBegin("tagger_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tagger_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_tagging", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->raw_tagging);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tagger_config) {
    xfer += oprot->writeFieldBegin("tagger_config", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tagger_config);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagger_version) {
    xfer += oprot->writeFieldBegin("tagger_version", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tagger_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generation_time) {
    xfer += oprot->writeFieldBegin("generation_time", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->generation_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Tagging &a, Tagging &b) {
  using ::std::swap;
  swap(a.tagger_id, b.tagger_id);
  swap(a.raw_tagging, b.raw_tagging);
  swap(a.tagger_config, b.tagger_config);
  swap(a.tagger_version, b.tagger_version);
  swap(a.generation_time, b.generation_time);
  swap(a.__isset, b.__isset);
}

const char* Relation::ascii_fingerprint = "50CD5AB579623D1F31762CDE35F209CF";
const uint8_t Relation::binary_fingerprint[16] = {0x50,0xCD,0x5A,0xB5,0x79,0x62,0x3D,0x1F,0x31,0x76,0x2C,0xDE,0x35,0xF2,0x09,0xCF};

uint32_t Relation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast55;
          xfer += iprot->readI32(ecast55);
          this->relation_type = (RelationType::type)ecast55;
          this->__isset.relation_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sentence_id_1);
          this->__isset.sentence_id_1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mention_id_1);
          this->__isset.mention_id_1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sentence_id_2);
          this->__isset.sentence_id_2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mention_id_2);
          this->__isset.mention_id_2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Relation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Relation");

  if (this->__isset.relation_type) {
    xfer += oprot->writeFieldBegin("relation_type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->relation_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_id_1) {
    xfer += oprot->writeFieldBegin("sentence_id_1", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->sentence_id_1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_id_1) {
    xfer += oprot->writeFieldBegin("mention_id_1", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->mention_id_1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_id_2) {
    xfer += oprot->writeFieldBegin("sentence_id_2", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->sentence_id_2);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_id_2) {
    xfer += oprot->writeFieldBegin("mention_id_2", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->mention_id_2);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Relation &a, Relation &b) {
  using ::std::swap;
  swap(a.relation_type, b.relation_type);
  swap(a.sentence_id_1, b.sentence_id_1);
  swap(a.mention_id_1, b.mention_id_1);
  swap(a.sentence_id_2, b.sentence_id_2);
  swap(a.mention_id_2, b.mention_id_2);
  swap(a.__isset, b.__isset);
}

const char* Language::ascii_fingerprint = "5B708A954C550ECA9C1A49D3C5CAFAB9";
const uint8_t Language::binary_fingerprint[16] = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

uint32_t Language::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Language::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Language");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Language &a, Language &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

const char* ContentItem::ascii_fingerprint = "670475A3A6B7F4C2D4C55C457B4A51ED";
const uint8_t ContentItem::binary_fingerprint[16] = {0x67,0x04,0x75,0xA3,0xA6,0xB7,0xF4,0xC2,0xD4,0xC5,0x5C,0x45,0x7B,0x4A,0x51,0xED};

uint32_t ContentItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->raw);
          this->__isset.raw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encoding);
          this->__isset.encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->media_type);
          this->__isset.media_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clean_html);
          this->__isset.clean_html = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clean_visible);
          this->__isset.clean_visible = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->logs.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->logs.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += iprot->readString(this->logs[_i60]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.logs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->taggings.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _ktype62;
            ::apache::thrift::protocol::TType _vtype63;
            xfer += iprot->readMapBegin(_ktype62, _vtype63, _size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              TaggerID _key66;
              xfer += iprot->readString(_key66);
              Tagging& _val67 = this->taggings[_key66];
              xfer += _val67.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.taggings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->labels.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _ktype69;
            ::apache::thrift::protocol::TType _vtype70;
            xfer += iprot->readMapBegin(_ktype69, _vtype70, _size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              AnnotatorID _key73;
              xfer += iprot->readString(_key73);
              std::vector<Label> & _val74 = this->labels[_key73];
              {
                _val74.clear();
                uint32_t _size75;
                ::apache::thrift::protocol::TType _etype78;
                xfer += iprot->readListBegin(_etype78, _size75);
                _val74.resize(_size75);
                uint32_t _i79;
                for (_i79 = 0; _i79 < _size75; ++_i79)
                {
                  xfer += _val74[_i79].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->sentences.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _ktype81;
            ::apache::thrift::protocol::TType _vtype82;
            xfer += iprot->readMapBegin(_ktype81, _vtype82, _size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              TaggerID _key85;
              xfer += iprot->readString(_key85);
              std::vector<Sentence> & _val86 = this->sentences[_key85];
              {
                _val86.clear();
                uint32_t _size87;
                ::apache::thrift::protocol::TType _etype90;
                xfer += iprot->readListBegin(_etype90, _size87);
                _val86.resize(_size87);
                uint32_t _i91;
                for (_i91 = 0; _i91 < _size87; ++_i91)
                {
                  xfer += _val86[_i91].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.sentences = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->sentence_blobs.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _ktype93;
            ::apache::thrift::protocol::TType _vtype94;
            xfer += iprot->readMapBegin(_ktype93, _vtype94, _size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              TaggerID _key97;
              xfer += iprot->readString(_key97);
              std::string& _val98 = this->sentence_blobs[_key97];
              xfer += iprot->readBinary(_val98);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.sentence_blobs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->language.read(iprot);
          this->__isset.language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->relations.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _ktype100;
            ::apache::thrift::protocol::TType _vtype101;
            xfer += iprot->readMapBegin(_ktype100, _vtype101, _size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              TaggerID _key104;
              xfer += iprot->readString(_key104);
              std::vector<Relation> & _val105 = this->relations[_key104];
              {
                _val105.clear();
                uint32_t _size106;
                ::apache::thrift::protocol::TType _etype109;
                xfer += iprot->readListBegin(_etype109, _size106);
                _val105.resize(_size106);
                uint32_t _i110;
                for (_i110 = 0; _i110 < _size106; ++_i110)
                {
                  xfer += _val105[_i110].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.relations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContentItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContentItem");

  if (this->__isset.raw) {
    xfer += oprot->writeFieldBegin("raw", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->raw);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encoding) {
    xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->encoding);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.media_type) {
    xfer += oprot->writeFieldBegin("media_type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->media_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clean_html) {
    xfer += oprot->writeFieldBegin("clean_html", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->clean_html);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clean_visible) {
    xfer += oprot->writeFieldBegin("clean_visible", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->clean_visible);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logs) {
    xfer += oprot->writeFieldBegin("logs", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->logs.size()));
      std::vector<std::string> ::const_iterator _iter111;
      for (_iter111 = this->logs.begin(); _iter111 != this->logs.end(); ++_iter111)
      {
        xfer += oprot->writeString((*_iter111));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.taggings) {
    xfer += oprot->writeFieldBegin("taggings", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->taggings.size()));
      std::map<TaggerID, Tagging> ::const_iterator _iter112;
      for (_iter112 = this->taggings.begin(); _iter112 != this->taggings.end(); ++_iter112)
      {
        xfer += oprot->writeString(_iter112->first);
        xfer += _iter112->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->labels.size()));
      std::map<AnnotatorID, std::vector<Label> > ::const_iterator _iter113;
      for (_iter113 = this->labels.begin(); _iter113 != this->labels.end(); ++_iter113)
      {
        xfer += oprot->writeString(_iter113->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter113->second.size()));
          std::vector<Label> ::const_iterator _iter114;
          for (_iter114 = _iter113->second.begin(); _iter114 != _iter113->second.end(); ++_iter114)
          {
            xfer += (*_iter114).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentences) {
    xfer += oprot->writeFieldBegin("sentences", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->sentences.size()));
      std::map<TaggerID, std::vector<Sentence> > ::const_iterator _iter115;
      for (_iter115 = this->sentences.begin(); _iter115 != this->sentences.end(); ++_iter115)
      {
        xfer += oprot->writeString(_iter115->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter115->second.size()));
          std::vector<Sentence> ::const_iterator _iter116;
          for (_iter116 = _iter115->second.begin(); _iter116 != _iter115->second.end(); ++_iter116)
          {
            xfer += (*_iter116).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_blobs) {
    xfer += oprot->writeFieldBegin("sentence_blobs", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sentence_blobs.size()));
      std::map<TaggerID, std::string> ::const_iterator _iter117;
      for (_iter117 = this->sentence_blobs.begin(); _iter117 != this->sentence_blobs.end(); ++_iter117)
      {
        xfer += oprot->writeString(_iter117->first);
        xfer += oprot->writeBinary(_iter117->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.language) {
    xfer += oprot->writeFieldBegin("language", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->language.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relations) {
    xfer += oprot->writeFieldBegin("relations", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->relations.size()));
      std::map<TaggerID, std::vector<Relation> > ::const_iterator _iter118;
      for (_iter118 = this->relations.begin(); _iter118 != this->relations.end(); ++_iter118)
      {
        xfer += oprot->writeString(_iter118->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter118->second.size()));
          std::vector<Relation> ::const_iterator _iter119;
          for (_iter119 = _iter118->second.begin(); _iter119 != _iter118->second.end(); ++_iter119)
          {
            xfer += (*_iter119).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContentItem &a, ContentItem &b) {
  using ::std::swap;
  swap(a.raw, b.raw);
  swap(a.encoding, b.encoding);
  swap(a.media_type, b.media_type);
  swap(a.clean_html, b.clean_html);
  swap(a.clean_visible, b.clean_visible);
  swap(a.logs, b.logs);
  swap(a.taggings, b.taggings);
  swap(a.labels, b.labels);
  swap(a.sentences, b.sentences);
  swap(a.sentence_blobs, b.sentence_blobs);
  swap(a.language, b.language);
  swap(a.relations, b.relations);
  swap(a.__isset, b.__isset);
}

const char* Rating::ascii_fingerprint = "DCBA8CB33AD8DD99F9FD43759B321154";
const uint8_t Rating::binary_fingerprint[16] = {0xDC,0xBA,0x8C,0xB3,0x3A,0xD8,0xDD,0x99,0xF9,0xFD,0x43,0x75,0x9B,0x32,0x11,0x54};

uint32_t Rating::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotator.read(iprot);
          this->__isset.annotator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->relevance);
          this->__isset.relevance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->contains_mention);
          this->__isset.contains_mention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mentions.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _etype123;
            xfer += iprot->readListBegin(_etype123, _size120);
            this->mentions.resize(_size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              xfer += iprot->readString(this->mentions[_i124]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mentions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Rating::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Rating");

  xfer += oprot->writeFieldBegin("annotator", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->annotator.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.relevance) {
    xfer += oprot->writeFieldBegin("relevance", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->relevance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.contains_mention) {
    xfer += oprot->writeFieldBegin("contains_mention", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->contains_mention);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comments) {
    xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->comments);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mentions) {
    xfer += oprot->writeFieldBegin("mentions", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->mentions.size()));
      std::vector<std::string> ::const_iterator _iter125;
      for (_iter125 = this->mentions.begin(); _iter125 != this->mentions.end(); ++_iter125)
      {
        xfer += oprot->writeString((*_iter125));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Rating &a, Rating &b) {
  using ::std::swap;
  swap(a.annotator, b.annotator);
  swap(a.target, b.target);
  swap(a.relevance, b.relevance);
  swap(a.contains_mention, b.contains_mention);
  swap(a.comments, b.comments);
  swap(a.mentions, b.mentions);
  swap(a.__isset, b.__isset);
}

const char* StreamItem::ascii_fingerprint = "C4D95535C65C60E73F2AFB6A4090C562";
const uint8_t StreamItem::binary_fingerprint[16] = {0xC4,0xD9,0x55,0x35,0xC6,0x5C,0x60,0xE7,0x3F,0x2A,0xFB,0x6A,0x40,0x90,0xC5,0x62};

uint32_t StreamItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast126;
          xfer += iprot->readI32(ecast126);
          this->version = (Versions::type)ecast126;
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc_id);
          this->__isset.doc_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->abs_url);
          this->__isset.abs_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schost);
          this->__isset.schost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->original_url);
          this->__isset.original_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->source_metadata.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _ktype128;
            ::apache::thrift::protocol::TType _vtype129;
            xfer += iprot->readMapBegin(_ktype128, _vtype129, _size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              std::string _key132;
              xfer += iprot->readString(_key132);
              SourceMetadata& _val133 = this->source_metadata[_key132];
              xfer += iprot->readBinary(_val133);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.source_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stream_id);
          this->__isset.stream_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stream_time.read(iprot);
          this->__isset.stream_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->other_content.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _ktype135;
            ::apache::thrift::protocol::TType _vtype136;
            xfer += iprot->readMapBegin(_ktype135, _vtype136, _size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              std::string _key139;
              xfer += iprot->readString(_key139);
              ContentItem& _val140 = this->other_content[_key139];
              xfer += _val140.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.other_content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ratings.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _ktype142;
            ::apache::thrift::protocol::TType _vtype143;
            xfer += iprot->readMapBegin(_ktype142, _vtype143, _size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              AnnotatorID _key146;
              xfer += iprot->readString(_key146);
              std::vector<Rating> & _val147 = this->ratings[_key146];
              {
                _val147.clear();
                uint32_t _size148;
                ::apache::thrift::protocol::TType _etype151;
                xfer += iprot->readListBegin(_etype151, _size148);
                _val147.resize(_size148);
                uint32_t _i152;
                for (_i152 = 0; _i152 < _size148; ++_i152)
                {
                  xfer += _val147[_i152].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ratings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StreamItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StreamItem");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doc_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->doc_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.abs_url) {
    xfer += oprot->writeFieldBegin("abs_url", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->abs_url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schost) {
    xfer += oprot->writeFieldBegin("schost", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->schost);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_url) {
    xfer += oprot->writeFieldBegin("original_url", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->original_url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->source);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->body.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source_metadata) {
    xfer += oprot->writeFieldBegin("source_metadata", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->source_metadata.size()));
      std::map<std::string, SourceMetadata> ::const_iterator _iter153;
      for (_iter153 = this->source_metadata.begin(); _iter153 != this->source_metadata.end(); ++_iter153)
      {
        xfer += oprot->writeString(_iter153->first);
        xfer += oprot->writeBinary(_iter153->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("stream_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->stream_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stream_time", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->stream_time.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_content) {
    xfer += oprot->writeFieldBegin("other_content", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_content.size()));
      std::map<std::string, ContentItem> ::const_iterator _iter154;
      for (_iter154 = this->other_content.begin(); _iter154 != this->other_content.end(); ++_iter154)
      {
        xfer += oprot->writeString(_iter154->first);
        xfer += _iter154->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ratings) {
    xfer += oprot->writeFieldBegin("ratings", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->ratings.size()));
      std::map<AnnotatorID, std::vector<Rating> > ::const_iterator _iter155;
      for (_iter155 = this->ratings.begin(); _iter155 != this->ratings.end(); ++_iter155)
      {
        xfer += oprot->writeString(_iter155->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter155->second.size()));
          std::vector<Rating> ::const_iterator _iter156;
          for (_iter156 = _iter155->second.begin(); _iter156 != _iter155->second.end(); ++_iter156)
          {
            xfer += (*_iter156).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StreamItem &a, StreamItem &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.doc_id, b.doc_id);
  swap(a.abs_url, b.abs_url);
  swap(a.schost, b.schost);
  swap(a.original_url, b.original_url);
  swap(a.source, b.source);
  swap(a.body, b.body);
  swap(a.source_metadata, b.source_metadata);
  swap(a.stream_id, b.stream_id);
  swap(a.stream_time, b.stream_time);
  swap(a.other_content, b.other_content);
  swap(a.ratings, b.ratings);
  swap(a.__isset, b.__isset);
}

} // namespace
