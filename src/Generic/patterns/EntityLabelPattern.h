// Copyright 2011 by BBN Technologies Corp.
// All Rights Reserved.

#ifndef ENTITY_LABEL_PATTERN_H
#define ENTITY_LABEL_PATTERN_H

#include "Generic/patterns/Pattern.h"
#include "Generic/patterns/PatternWordSet.h"
#include "Generic/common/BoostUtil.h"

class Sexp;
class PatternMatcher;
class PatternFeatureSet;
typedef boost::shared_ptr<PatternFeatureSet> PatternFeatureSet_ptr;
typedef Symbol::HashMap<boost::shared_ptr<Pattern> > SymbolToPatternMap;

/** A data structure associating an entity label with a pattern.  (Note 
  * that an EntityLabelPattern is not itself a Pattern object; instead, it
  * contains a reference to a Pattern object).  Each entity label pattern
  * consists of an entity label, which is a symbol typically written in 
  * ALLCAPS, and a pattern, which is typically an event pattern, a prop
  * pattern, or a relation pattern.  That pattern is required to contain
  * at least one MentionPattern that is marked as a "FOCUS".  When the
  * entity patterns are run, all mentions that match a FOCUS MentionPattern
  * will have their corresponding entity labeled with the EntityLabelPattern's
  * entity label.  This labeling can then be used by subsequent patterns
  * as a constraint.
  */
class EntityLabelPattern {
private:
	/** Create an empty EntityLabelPattern with a given label.  This is used 
	  * to record the fact that an entity label is available when it is 
	  * generated by a source outside the pattern system. */
	EntityLabelPattern(Symbol label);
	BOOST_MAKE_SHARED_1ARG_CONSTRUCTOR(EntityLabelPattern, Symbol);

	/** Create a new EntityLabelPattern from an sexpr */
	EntityLabelPattern(Sexp *sexp, const Symbol::HashSet &entityLabels, const PatternWordSetMap& wordSets);
	BOOST_MAKE_SHARED_3ARG_CONSTRUCTOR(EntityLabelPattern, Sexp*, const Symbol::HashSet&, const PatternWordSetMap&);

public:
	/** Return the label that identifies this entity-label pattern. */
	Symbol getLabel() const { return _label; }

	/** Return true if this entity label pattern has a pattern.  This may
	  * be false for special labels like AGENT1 that get added automatically. */
	bool hasPattern() const { return _pattern; }

	/** A map from entityid to the pattern feature set generated when this
	  * entity was labeled. The existence of the feature set indicates
	  * whether this entity should be tagged with a given label. The keys of 
	  * this map are the entity ids of the entities that are tagged with the 
	  * label. */
	typedef std::map<int, PatternFeatureSet_ptr> EntityLabelFeatureMap;

	/** A map from entity label to EntityLabelFeatureMap. */
	typedef Symbol::HashMap<EntityLabelPattern::EntityLabelFeatureMap> EntityLabeling;

	/** Run this pattern over the given document, and assign feature sets (null
	  * or otherwise) to entities. */
	void labelEntities(PatternMatcher_ptr patternMatcher, EntityLabelFeatureMap& result) const;

	/** Run this pattern over the given document, and use the results to update
	  * the given entityLabeling. */
	void labelEntities(PatternMatcher_ptr patternMatcher, EntityLabeling& result) const {
		labelEntities(patternMatcher, result[_label]);
	}

	/** Replace shortcuts (there are none) and do any side-effects of calling replace shortcuts,
	  * such as replacing CombinationPatterns with their deduced type. */
	void replaceShortcuts(const SymbolToPatternMap& refPatterns);

private:
	// The label assigned to entities by this EntityLabelPattern
	Symbol _label;

	// The pattern used to find entities to label.  Any mention that matches
	// a MentionPattern subpattern marked as a FOCUS will have its 
	// corresponding entity labeled with _label.
	Pattern_ptr _pattern;

	void labelFeatureSet(PatternFeatureSet_ptr sfs, PatternMatcher_ptr patternMatcher, 
	                     EntityLabelFeatureMap &entityMapping) const;
};

typedef boost::shared_ptr<EntityLabelPattern> EntityLabelPattern_ptr;

#endif
