// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: instances.proto

#ifndef PROTOBUF_instances_2eproto__INCLUDED
#define PROTOBUF_instances_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace learnit {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_instances_2eproto();
void protobuf_AssignDesc_instances_2eproto();
void protobuf_ShutdownFile_instances_2eproto();

class NameSpan;
class SentenceTheory;
class BestName;
class Role;
class SlotFiller;
class Arg;
class Prop;
class PatternMatch;
class SeedInstanceMatch;
class TokenAlignment;
class MentionAlignment;
class SentenceAlignment;
class Sentence;
class Instance;

// ===================================================================

class NameSpan : public ::google::protobuf::Message {
 public:
  NameSpan();
  virtual ~NameSpan();

  NameSpan(const NameSpan& from);

  inline NameSpan& operator=(const NameSpan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameSpan& default_instance();

  void Swap(NameSpan* other);

  // implements Message ----------------------------------------------

  NameSpan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameSpan& from);
  void MergeFrom(const NameSpan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mentionType = 1;
  inline bool has_mentiontype() const;
  inline void clear_mentiontype();
  static const int kMentionTypeFieldNumber = 1;
  inline const ::std::string& mentiontype() const;
  inline void set_mentiontype(const ::std::string& value);
  inline void set_mentiontype(const char* value);
  inline void set_mentiontype(const char* value, size_t size);
  inline ::std::string* mutable_mentiontype();
  inline ::std::string* release_mentiontype();
  inline void set_allocated_mentiontype(::std::string* mentiontype);

  // optional string entityType = 2;
  inline bool has_entitytype() const;
  inline void clear_entitytype();
  static const int kEntityTypeFieldNumber = 2;
  inline const ::std::string& entitytype() const;
  inline void set_entitytype(const ::std::string& value);
  inline void set_entitytype(const char* value);
  inline void set_entitytype(const char* value, size_t size);
  inline ::std::string* mutable_entitytype();
  inline ::std::string* release_entitytype();
  inline void set_allocated_entitytype(::std::string* entitytype);

  // optional string entitySubtype = 3;
  inline bool has_entitysubtype() const;
  inline void clear_entitysubtype();
  static const int kEntitySubtypeFieldNumber = 3;
  inline const ::std::string& entitysubtype() const;
  inline void set_entitysubtype(const ::std::string& value);
  inline void set_entitysubtype(const char* value);
  inline void set_entitysubtype(const char* value, size_t size);
  inline ::std::string* mutable_entitysubtype();
  inline ::std::string* release_entitysubtype();
  inline void set_allocated_entitysubtype(::std::string* entitysubtype);

  // repeated string allMentions = 4;
  inline int allmentions_size() const;
  inline void clear_allmentions();
  static const int kAllMentionsFieldNumber = 4;
  inline const ::std::string& allmentions(int index) const;
  inline ::std::string* mutable_allmentions(int index);
  inline void set_allmentions(int index, const ::std::string& value);
  inline void set_allmentions(int index, const char* value);
  inline void set_allmentions(int index, const char* value, size_t size);
  inline ::std::string* add_allmentions();
  inline void add_allmentions(const ::std::string& value);
  inline void add_allmentions(const char* value);
  inline void add_allmentions(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& allmentions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_allmentions();

  // optional int32 start = 5;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 5;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);

  // optional int32 end = 6;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 6;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:learnit.NameSpan)
 private:
  inline void set_has_mentiontype();
  inline void clear_has_mentiontype();
  inline void set_has_entitytype();
  inline void clear_has_entitytype();
  inline void set_has_entitysubtype();
  inline void clear_has_entitysubtype();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mentiontype_;
  ::std::string* entitytype_;
  ::std::string* entitysubtype_;
  ::google::protobuf::RepeatedPtrField< ::std::string> allmentions_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static NameSpan* default_instance_;
};
// -------------------------------------------------------------------

class SentenceTheory : public ::google::protobuf::Message {
 public:
  SentenceTheory();
  virtual ~SentenceTheory();

  SentenceTheory(const SentenceTheory& from);

  inline SentenceTheory& operator=(const SentenceTheory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SentenceTheory& default_instance();

  void Swap(SentenceTheory* other);

  // implements Message ----------------------------------------------

  SentenceTheory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SentenceTheory& from);
  void MergeFrom(const SentenceTheory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string docid = 1;
  inline bool has_docid() const;
  inline void clear_docid();
  static const int kDocidFieldNumber = 1;
  inline const ::std::string& docid() const;
  inline void set_docid(const ::std::string& value);
  inline void set_docid(const char* value);
  inline void set_docid(const char* value, size_t size);
  inline ::std::string* mutable_docid();
  inline ::std::string* release_docid();
  inline void set_allocated_docid(::std::string* docid);

  // optional string language = 2;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 2;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional int32 sentIndex = 3;
  inline bool has_sentindex() const;
  inline void clear_sentindex();
  static const int kSentIndexFieldNumber = 3;
  inline ::google::protobuf::int32 sentindex() const;
  inline void set_sentindex(::google::protobuf::int32 value);

  // repeated string token = 4;
  inline int token_size() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token(int index) const;
  inline ::std::string* mutable_token(int index);
  inline void set_token(int index, const ::std::string& value);
  inline void set_token(int index, const char* value);
  inline void set_token(int index, const char* value, size_t size);
  inline ::std::string* add_token();
  inline void add_token(const ::std::string& value);
  inline void add_token(const char* value);
  inline void add_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_token();

  // repeated string docEvent = 5;
  inline int docevent_size() const;
  inline void clear_docevent();
  static const int kDocEventFieldNumber = 5;
  inline const ::std::string& docevent(int index) const;
  inline ::std::string* mutable_docevent(int index);
  inline void set_docevent(int index, const ::std::string& value);
  inline void set_docevent(int index, const char* value);
  inline void set_docevent(int index, const char* value, size_t size);
  inline ::std::string* add_docevent();
  inline void add_docevent(const ::std::string& value);
  inline void add_docevent(const char* value);
  inline void add_docevent(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& docevent() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_docevent();

  // repeated string sentEvent = 6;
  inline int sentevent_size() const;
  inline void clear_sentevent();
  static const int kSentEventFieldNumber = 6;
  inline const ::std::string& sentevent(int index) const;
  inline ::std::string* mutable_sentevent(int index);
  inline void set_sentevent(int index, const ::std::string& value);
  inline void set_sentevent(int index, const char* value);
  inline void set_sentevent(int index, const char* value, size_t size);
  inline ::std::string* add_sentevent();
  inline void add_sentevent(const ::std::string& value);
  inline void add_sentevent(const char* value);
  inline void add_sentevent(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sentevent() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sentevent();

  // repeated .learnit.NameSpan nameSpan = 7;
  inline int namespan_size() const;
  inline void clear_namespan();
  static const int kNameSpanFieldNumber = 7;
  inline const ::learnit::NameSpan& namespan(int index) const;
  inline ::learnit::NameSpan* mutable_namespan(int index);
  inline ::learnit::NameSpan* add_namespan();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::NameSpan >&
      namespan() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::NameSpan >*
      mutable_namespan();

  // @@protoc_insertion_point(class_scope:learnit.SentenceTheory)
 private:
  inline void set_has_docid();
  inline void clear_has_docid();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_sentindex();
  inline void clear_has_sentindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* docid_;
  ::std::string* language_;
  ::google::protobuf::RepeatedPtrField< ::std::string> token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> docevent_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sentevent_;
  ::google::protobuf::RepeatedPtrField< ::learnit::NameSpan > namespan_;
  ::google::protobuf::int32 sentindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static SentenceTheory* default_instance_;
};
// -------------------------------------------------------------------

class BestName : public ::google::protobuf::Message {
 public:
  BestName();
  virtual ~BestName();

  BestName(const BestName& from);

  inline BestName& operator=(const BestName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BestName& default_instance();

  void Swap(BestName* other);

  // implements Message ----------------------------------------------

  BestName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BestName& from);
  void MergeFrom(const BestName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double confidence = 1;
  inline bool has_confidence() const;
  inline void clear_confidence();
  static const int kConfidenceFieldNumber = 1;
  inline double confidence() const;
  inline void set_confidence(double value);

  // optional string mentionType = 2;
  inline bool has_mentiontype() const;
  inline void clear_mentiontype();
  static const int kMentionTypeFieldNumber = 2;
  inline const ::std::string& mentiontype() const;
  inline void set_mentiontype(const ::std::string& value);
  inline void set_mentiontype(const char* value);
  inline void set_mentiontype(const char* value, size_t size);
  inline ::std::string* mutable_mentiontype();
  inline ::std::string* release_mentiontype();
  inline void set_allocated_mentiontype(::std::string* mentiontype);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:learnit.BestName)
 private:
  inline void set_has_confidence();
  inline void clear_has_confidence();
  inline void set_has_mentiontype();
  inline void clear_has_mentiontype();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double confidence_;
  ::std::string* mentiontype_;
  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static BestName* default_instance_;
};
// -------------------------------------------------------------------

class Role : public ::google::protobuf::Message {
 public:
  Role();
  virtual ~Role();

  Role(const Role& from);

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role& default_instance();

  void Swap(Role* other);

  // implements Message ----------------------------------------------

  Role* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:learnit.Role)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static Role* default_instance_;
};
// -------------------------------------------------------------------

class SlotFiller : public ::google::protobuf::Message {
 public:
  SlotFiller();
  virtual ~SlotFiller();

  SlotFiller(const SlotFiller& from);

  inline SlotFiller& operator=(const SlotFiller& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlotFiller& default_instance();

  void Swap(SlotFiller* other);

  // implements Message ----------------------------------------------

  SlotFiller* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlotFiller& from);
  void MergeFrom(const SlotFiller& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 slot = 1;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 1;
  inline ::google::protobuf::int32 slot() const;
  inline void set_slot(::google::protobuf::int32 value);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional int32 startToken = 3;
  inline bool has_starttoken() const;
  inline void clear_starttoken();
  static const int kStartTokenFieldNumber = 3;
  inline ::google::protobuf::int32 starttoken() const;
  inline void set_starttoken(::google::protobuf::int32 value);

  // optional int32 endToken = 4;
  inline bool has_endtoken() const;
  inline void clear_endtoken();
  static const int kEndTokenFieldNumber = 4;
  inline ::google::protobuf::int32 endtoken() const;
  inline void set_endtoken(::google::protobuf::int32 value);

  // optional int32 headStartToken = 5;
  inline bool has_headstarttoken() const;
  inline void clear_headstarttoken();
  static const int kHeadStartTokenFieldNumber = 5;
  inline ::google::protobuf::int32 headstarttoken() const;
  inline void set_headstarttoken(::google::protobuf::int32 value);

  // optional int32 headEndToken = 6;
  inline bool has_headendtoken() const;
  inline void clear_headendtoken();
  static const int kHeadEndTokenFieldNumber = 6;
  inline ::google::protobuf::int32 headendtoken() const;
  inline void set_headendtoken(::google::protobuf::int32 value);

  // optional string mentionType = 7;
  inline bool has_mentiontype() const;
  inline void clear_mentiontype();
  static const int kMentionTypeFieldNumber = 7;
  inline const ::std::string& mentiontype() const;
  inline void set_mentiontype(const ::std::string& value);
  inline void set_mentiontype(const char* value);
  inline void set_mentiontype(const char* value, size_t size);
  inline ::std::string* mutable_mentiontype();
  inline ::std::string* release_mentiontype();
  inline void set_allocated_mentiontype(::std::string* mentiontype);

  // optional string text = 8;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 8;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string seedString = 9;
  inline bool has_seedstring() const;
  inline void clear_seedstring();
  static const int kSeedStringFieldNumber = 9;
  inline const ::std::string& seedstring() const;
  inline void set_seedstring(const ::std::string& value);
  inline void set_seedstring(const char* value);
  inline void set_seedstring(const char* value, size_t size);
  inline ::std::string* mutable_seedstring();
  inline ::std::string* release_seedstring();
  inline void set_allocated_seedstring(::std::string* seedstring);

  // repeated .learnit.Role role = 10;
  inline int role_size() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 10;
  inline const ::learnit::Role& role(int index) const;
  inline ::learnit::Role* mutable_role(int index);
  inline ::learnit::Role* add_role();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::Role >&
      role() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::Role >*
      mutable_role();

  // optional .learnit.BestName bestName = 11;
  inline bool has_bestname() const;
  inline void clear_bestname();
  static const int kBestNameFieldNumber = 11;
  inline const ::learnit::BestName& bestname() const;
  inline ::learnit::BestName* mutable_bestname();
  inline ::learnit::BestName* release_bestname();
  inline void set_allocated_bestname(::learnit::BestName* bestname);

  // optional string language = 12;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 12;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:learnit.SlotFiller)
 private:
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_starttoken();
  inline void clear_has_starttoken();
  inline void set_has_endtoken();
  inline void clear_has_endtoken();
  inline void set_has_headstarttoken();
  inline void clear_has_headstarttoken();
  inline void set_has_headendtoken();
  inline void clear_has_headendtoken();
  inline void set_has_mentiontype();
  inline void clear_has_mentiontype();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_seedstring();
  inline void clear_has_seedstring();
  inline void set_has_bestname();
  inline void clear_has_bestname();
  inline void set_has_language();
  inline void clear_has_language();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::google::protobuf::int32 slot_;
  ::google::protobuf::int32 starttoken_;
  ::google::protobuf::int32 endtoken_;
  ::google::protobuf::int32 headstarttoken_;
  ::std::string* mentiontype_;
  ::std::string* text_;
  ::std::string* seedstring_;
  ::google::protobuf::RepeatedPtrField< ::learnit::Role > role_;
  ::learnit::BestName* bestname_;
  ::std::string* language_;
  ::google::protobuf::int32 headendtoken_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static SlotFiller* default_instance_;
};
// -------------------------------------------------------------------

class Arg : public ::google::protobuf::Message {
 public:
  Arg();
  virtual ~Arg();

  Arg(const Arg& from);

  inline Arg& operator=(const Arg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Arg& default_instance();

  void Swap(Arg* other);

  // implements Message ----------------------------------------------

  Arg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Arg& from);
  void MergeFrom(const Arg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 propChildId = 1;
  inline int propchildid_size() const;
  inline void clear_propchildid();
  static const int kPropChildIdFieldNumber = 1;
  inline ::google::protobuf::int32 propchildid(int index) const;
  inline void set_propchildid(int index, ::google::protobuf::int32 value);
  inline void add_propchildid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      propchildid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_propchildid();

  // optional string role = 2;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 2;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // optional string lex = 3;
  inline bool has_lex() const;
  inline void clear_lex();
  static const int kLexFieldNumber = 3;
  inline const ::std::string& lex() const;
  inline void set_lex(const ::std::string& value);
  inline void set_lex(const char* value);
  inline void set_lex(const char* value, size_t size);
  inline ::std::string* mutable_lex();
  inline ::std::string* release_lex();
  inline void set_allocated_lex(::std::string* lex);

  // repeated int32 slot = 4;
  inline int slot_size() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 4;
  inline ::google::protobuf::int32 slot(int index) const;
  inline void set_slot(int index, ::google::protobuf::int32 value);
  inline void add_slot(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      slot() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_slot();

  // @@protoc_insertion_point(class_scope:learnit.Arg)
 private:
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_lex();
  inline void clear_has_lex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > propchildid_;
  ::std::string* role_;
  ::std::string* lex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > slot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static Arg* default_instance_;
};
// -------------------------------------------------------------------

class Prop : public ::google::protobuf::Message {
 public:
  Prop();
  virtual ~Prop();

  Prop(const Prop& from);

  inline Prop& operator=(const Prop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Prop& default_instance();

  void Swap(Prop* other);

  // implements Message ----------------------------------------------

  Prop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Prop& from);
  void MergeFrom(const Prop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .learnit.Arg arg = 1;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 1;
  inline const ::learnit::Arg& arg(int index) const;
  inline ::learnit::Arg* mutable_arg(int index);
  inline ::learnit::Arg* add_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::Arg >&
      arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::Arg >*
      mutable_arg();

  // optional string kind = 2;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 2;
  inline const ::std::string& kind() const;
  inline void set_kind(const ::std::string& value);
  inline void set_kind(const char* value);
  inline void set_kind(const char* value, size_t size);
  inline ::std::string* mutable_kind();
  inline ::std::string* release_kind();
  inline void set_allocated_kind(::std::string* kind);

  // optional string predicate = 3;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 3;
  inline const ::std::string& predicate() const;
  inline void set_predicate(const ::std::string& value);
  inline void set_predicate(const char* value);
  inline void set_predicate(const char* value, size_t size);
  inline ::std::string* mutable_predicate();
  inline ::std::string* release_predicate();
  inline void set_allocated_predicate(::std::string* predicate);

  // @@protoc_insertion_point(class_scope:learnit.Prop)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_predicate();
  inline void clear_has_predicate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::learnit::Arg > arg_;
  ::std::string* kind_;
  ::std::string* predicate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static Prop* default_instance_;
};
// -------------------------------------------------------------------

class PatternMatch : public ::google::protobuf::Message {
 public:
  PatternMatch();
  virtual ~PatternMatch();

  PatternMatch(const PatternMatch& from);

  inline PatternMatch& operator=(const PatternMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatternMatch& default_instance();

  void Swap(PatternMatch* other);

  // implements Message ----------------------------------------------

  PatternMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatternMatch& from);
  void MergeFrom(const PatternMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // optional string pattern = 2;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 2;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional int32 startToken = 3;
  inline bool has_starttoken() const;
  inline void clear_starttoken();
  static const int kStartTokenFieldNumber = 3;
  inline ::google::protobuf::int32 starttoken() const;
  inline void set_starttoken(::google::protobuf::int32 value);

  // optional int32 endToken = 4;
  inline bool has_endtoken() const;
  inline void clear_endtoken();
  static const int kEndTokenFieldNumber = 4;
  inline ::google::protobuf::int32 endtoken() const;
  inline void set_endtoken(::google::protobuf::int32 value);

  // repeated .learnit.SlotFiller slot = 5;
  inline int slot_size() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 5;
  inline const ::learnit::SlotFiller& slot(int index) const;
  inline ::learnit::SlotFiller* mutable_slot(int index);
  inline ::learnit::SlotFiller* add_slot();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller >&
      slot() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller >*
      mutable_slot();

  // @@protoc_insertion_point(class_scope:learnit.PatternMatch)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_starttoken();
  inline void clear_has_starttoken();
  inline void set_has_endtoken();
  inline void clear_has_endtoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* target_;
  ::std::string* pattern_;
  ::google::protobuf::int32 starttoken_;
  ::google::protobuf::int32 endtoken_;
  ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller > slot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static PatternMatch* default_instance_;
};
// -------------------------------------------------------------------

class SeedInstanceMatch : public ::google::protobuf::Message {
 public:
  SeedInstanceMatch();
  virtual ~SeedInstanceMatch();

  SeedInstanceMatch(const SeedInstanceMatch& from);

  inline SeedInstanceMatch& operator=(const SeedInstanceMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SeedInstanceMatch& default_instance();

  void Swap(SeedInstanceMatch* other);

  // implements Message ----------------------------------------------

  SeedInstanceMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeedInstanceMatch& from);
  void MergeFrom(const SeedInstanceMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // repeated string relationMatch = 2;
  inline int relationmatch_size() const;
  inline void clear_relationmatch();
  static const int kRelationMatchFieldNumber = 2;
  inline const ::std::string& relationmatch(int index) const;
  inline ::std::string* mutable_relationmatch(int index);
  inline void set_relationmatch(int index, const ::std::string& value);
  inline void set_relationmatch(int index, const char* value);
  inline void set_relationmatch(int index, const char* value, size_t size);
  inline ::std::string* add_relationmatch();
  inline void add_relationmatch(const ::std::string& value);
  inline void add_relationmatch(const char* value);
  inline void add_relationmatch(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& relationmatch() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_relationmatch();

  // repeated string eventMatch = 3;
  inline int eventmatch_size() const;
  inline void clear_eventmatch();
  static const int kEventMatchFieldNumber = 3;
  inline const ::std::string& eventmatch(int index) const;
  inline ::std::string* mutable_eventmatch(int index);
  inline void set_eventmatch(int index, const ::std::string& value);
  inline void set_eventmatch(int index, const char* value);
  inline void set_eventmatch(int index, const char* value, size_t size);
  inline ::std::string* add_eventmatch();
  inline void add_eventmatch(const ::std::string& value);
  inline void add_eventmatch(const char* value);
  inline void add_eventmatch(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& eventmatch() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_eventmatch();

  // repeated string eventAnchor = 4;
  inline int eventanchor_size() const;
  inline void clear_eventanchor();
  static const int kEventAnchorFieldNumber = 4;
  inline const ::std::string& eventanchor(int index) const;
  inline ::std::string* mutable_eventanchor(int index);
  inline void set_eventanchor(int index, const ::std::string& value);
  inline void set_eventanchor(int index, const char* value);
  inline void set_eventanchor(int index, const char* value, size_t size);
  inline ::std::string* add_eventanchor();
  inline void add_eventanchor(const ::std::string& value);
  inline void add_eventanchor(const char* value);
  inline void add_eventanchor(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& eventanchor() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_eventanchor();

  // optional double score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline double score() const;
  inline void set_score(double value);

  // repeated .learnit.SlotFiller slot = 6;
  inline int slot_size() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 6;
  inline const ::learnit::SlotFiller& slot(int index) const;
  inline ::learnit::SlotFiller* mutable_slot(int index);
  inline ::learnit::SlotFiller* add_slot();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller >&
      slot() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller >*
      mutable_slot();

  // repeated .learnit.Prop prop = 7;
  inline int prop_size() const;
  inline void clear_prop();
  static const int kPropFieldNumber = 7;
  inline const ::learnit::Prop& prop(int index) const;
  inline ::learnit::Prop* mutable_prop(int index);
  inline ::learnit::Prop* add_prop();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::Prop >&
      prop() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::Prop >*
      mutable_prop();

  // optional string type = 8 [default = "seed"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:learnit.SeedInstanceMatch)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* target_;
  ::google::protobuf::RepeatedPtrField< ::std::string> relationmatch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> eventmatch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> eventanchor_;
  double score_;
  ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller > slot_;
  ::google::protobuf::RepeatedPtrField< ::learnit::Prop > prop_;
  ::std::string* type_;
  static ::std::string* _default_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static SeedInstanceMatch* default_instance_;
};
// -------------------------------------------------------------------

class TokenAlignment : public ::google::protobuf::Message {
 public:
  TokenAlignment();
  virtual ~TokenAlignment();

  TokenAlignment(const TokenAlignment& from);

  inline TokenAlignment& operator=(const TokenAlignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TokenAlignment& default_instance();

  void Swap(TokenAlignment* other);

  // implements Message ----------------------------------------------

  TokenAlignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TokenAlignment& from);
  void MergeFrom(const TokenAlignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sourceIndex = 1;
  inline bool has_sourceindex() const;
  inline void clear_sourceindex();
  static const int kSourceIndexFieldNumber = 1;
  inline ::google::protobuf::int32 sourceindex() const;
  inline void set_sourceindex(::google::protobuf::int32 value);

  // repeated int32 targetIndex = 2;
  inline int targetindex_size() const;
  inline void clear_targetindex();
  static const int kTargetIndexFieldNumber = 2;
  inline ::google::protobuf::int32 targetindex(int index) const;
  inline void set_targetindex(int index, ::google::protobuf::int32 value);
  inline void add_targetindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      targetindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_targetindex();

  // @@protoc_insertion_point(class_scope:learnit.TokenAlignment)
 private:
  inline void set_has_sourceindex();
  inline void clear_has_sourceindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > targetindex_;
  ::google::protobuf::int32 sourceindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static TokenAlignment* default_instance_;
};
// -------------------------------------------------------------------

class MentionAlignment : public ::google::protobuf::Message {
 public:
  MentionAlignment();
  virtual ~MentionAlignment();

  MentionAlignment(const MentionAlignment& from);

  inline MentionAlignment& operator=(const MentionAlignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MentionAlignment& default_instance();

  void Swap(MentionAlignment* other);

  // implements Message ----------------------------------------------

  MentionAlignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MentionAlignment& from);
  void MergeFrom(const MentionAlignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .learnit.NameSpan sourceMention = 1;
  inline bool has_sourcemention() const;
  inline void clear_sourcemention();
  static const int kSourceMentionFieldNumber = 1;
  inline const ::learnit::NameSpan& sourcemention() const;
  inline ::learnit::NameSpan* mutable_sourcemention();
  inline ::learnit::NameSpan* release_sourcemention();
  inline void set_allocated_sourcemention(::learnit::NameSpan* sourcemention);

  // optional .learnit.NameSpan targetMention = 2;
  inline bool has_targetmention() const;
  inline void clear_targetmention();
  static const int kTargetMentionFieldNumber = 2;
  inline const ::learnit::NameSpan& targetmention() const;
  inline ::learnit::NameSpan* mutable_targetmention();
  inline ::learnit::NameSpan* release_targetmention();
  inline void set_allocated_targetmention(::learnit::NameSpan* targetmention);

  // @@protoc_insertion_point(class_scope:learnit.MentionAlignment)
 private:
  inline void set_has_sourcemention();
  inline void clear_has_sourcemention();
  inline void set_has_targetmention();
  inline void clear_has_targetmention();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::learnit::NameSpan* sourcemention_;
  ::learnit::NameSpan* targetmention_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static MentionAlignment* default_instance_;
};
// -------------------------------------------------------------------

class SentenceAlignment : public ::google::protobuf::Message {
 public:
  SentenceAlignment();
  virtual ~SentenceAlignment();

  SentenceAlignment(const SentenceAlignment& from);

  inline SentenceAlignment& operator=(const SentenceAlignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SentenceAlignment& default_instance();

  void Swap(SentenceAlignment* other);

  // implements Message ----------------------------------------------

  SentenceAlignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SentenceAlignment& from);
  void MergeFrom(const SentenceAlignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string source = 3;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 3;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // optional string target = 4;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 4;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // repeated .learnit.TokenAlignment tokenAlignment = 5;
  inline int tokenalignment_size() const;
  inline void clear_tokenalignment();
  static const int kTokenAlignmentFieldNumber = 5;
  inline const ::learnit::TokenAlignment& tokenalignment(int index) const;
  inline ::learnit::TokenAlignment* mutable_tokenalignment(int index);
  inline ::learnit::TokenAlignment* add_tokenalignment();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::TokenAlignment >&
      tokenalignment() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::TokenAlignment >*
      mutable_tokenalignment();

  // repeated .learnit.MentionAlignment mentionAlignment = 6;
  inline int mentionalignment_size() const;
  inline void clear_mentionalignment();
  static const int kMentionAlignmentFieldNumber = 6;
  inline const ::learnit::MentionAlignment& mentionalignment(int index) const;
  inline ::learnit::MentionAlignment* mutable_mentionalignment(int index);
  inline ::learnit::MentionAlignment* add_mentionalignment();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::MentionAlignment >&
      mentionalignment() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::MentionAlignment >*
      mutable_mentionalignment();

  // @@protoc_insertion_point(class_scope:learnit.SentenceAlignment)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* source_;
  ::std::string* target_;
  ::google::protobuf::RepeatedPtrField< ::learnit::TokenAlignment > tokenalignment_;
  ::google::protobuf::RepeatedPtrField< ::learnit::MentionAlignment > mentionalignment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static SentenceAlignment* default_instance_;
};
// -------------------------------------------------------------------

class Sentence : public ::google::protobuf::Message {
 public:
  Sentence();
  virtual ~Sentence();

  Sentence(const Sentence& from);

  inline Sentence& operator=(const Sentence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sentence& default_instance();

  void Swap(Sentence* other);

  // implements Message ----------------------------------------------

  Sentence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sentence& from);
  void MergeFrom(const Sentence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .learnit.SentenceTheory sentenceTheory = 1;
  inline int sentencetheory_size() const;
  inline void clear_sentencetheory();
  static const int kSentenceTheoryFieldNumber = 1;
  inline const ::learnit::SentenceTheory& sentencetheory(int index) const;
  inline ::learnit::SentenceTheory* mutable_sentencetheory(int index);
  inline ::learnit::SentenceTheory* add_sentencetheory();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::SentenceTheory >&
      sentencetheory() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::SentenceTheory >*
      mutable_sentencetheory();

  // repeated .learnit.SentenceAlignment sentenceAlignment = 2;
  inline int sentencealignment_size() const;
  inline void clear_sentencealignment();
  static const int kSentenceAlignmentFieldNumber = 2;
  inline const ::learnit::SentenceAlignment& sentencealignment(int index) const;
  inline ::learnit::SentenceAlignment* mutable_sentencealignment(int index);
  inline ::learnit::SentenceAlignment* add_sentencealignment();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::SentenceAlignment >&
      sentencealignment() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::SentenceAlignment >*
      mutable_sentencealignment();

  // repeated .learnit.PatternMatch patternMatch = 3;
  inline int patternmatch_size() const;
  inline void clear_patternmatch();
  static const int kPatternMatchFieldNumber = 3;
  inline const ::learnit::PatternMatch& patternmatch(int index) const;
  inline ::learnit::PatternMatch* mutable_patternmatch(int index);
  inline ::learnit::PatternMatch* add_patternmatch();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::PatternMatch >&
      patternmatch() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::PatternMatch >*
      mutable_patternmatch();

  // repeated .learnit.SeedInstanceMatch seedInstanceMatch = 4;
  inline int seedinstancematch_size() const;
  inline void clear_seedinstancematch();
  static const int kSeedInstanceMatchFieldNumber = 4;
  inline const ::learnit::SeedInstanceMatch& seedinstancematch(int index) const;
  inline ::learnit::SeedInstanceMatch* mutable_seedinstancematch(int index);
  inline ::learnit::SeedInstanceMatch* add_seedinstancematch();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::SeedInstanceMatch >&
      seedinstancematch() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::SeedInstanceMatch >*
      mutable_seedinstancematch();

  // @@protoc_insertion_point(class_scope:learnit.Sentence)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::learnit::SentenceTheory > sentencetheory_;
  ::google::protobuf::RepeatedPtrField< ::learnit::SentenceAlignment > sentencealignment_;
  ::google::protobuf::RepeatedPtrField< ::learnit::PatternMatch > patternmatch_;
  ::google::protobuf::RepeatedPtrField< ::learnit::SeedInstanceMatch > seedinstancematch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static Sentence* default_instance_;
};
// -------------------------------------------------------------------

class Instance : public ::google::protobuf::Message {
 public:
  Instance();
  virtual ~Instance();

  Instance(const Instance& from);

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Instance& default_instance();

  void Swap(Instance* other);

  // implements Message ----------------------------------------------

  Instance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .learnit.Sentence sentence = 1;
  inline int sentence_size() const;
  inline void clear_sentence();
  static const int kSentenceFieldNumber = 1;
  inline const ::learnit::Sentence& sentence(int index) const;
  inline ::learnit::Sentence* mutable_sentence(int index);
  inline ::learnit::Sentence* add_sentence();
  inline const ::google::protobuf::RepeatedPtrField< ::learnit::Sentence >&
      sentence() const;
  inline ::google::protobuf::RepeatedPtrField< ::learnit::Sentence >*
      mutable_sentence();

  // @@protoc_insertion_point(class_scope:learnit.Instance)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::learnit::Sentence > sentence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_instances_2eproto();
  friend void protobuf_AssignDesc_instances_2eproto();
  friend void protobuf_ShutdownFile_instances_2eproto();

  void InitAsDefaultInstance();
  static Instance* default_instance_;
};
// ===================================================================


// ===================================================================

// NameSpan

// optional string mentionType = 1;
inline bool NameSpan::has_mentiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameSpan::set_has_mentiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameSpan::clear_has_mentiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameSpan::clear_mentiontype() {
  if (mentiontype_ != &::google::protobuf::internal::kEmptyString) {
    mentiontype_->clear();
  }
  clear_has_mentiontype();
}
inline const ::std::string& NameSpan::mentiontype() const {
  return *mentiontype_;
}
inline void NameSpan::set_mentiontype(const ::std::string& value) {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  mentiontype_->assign(value);
}
inline void NameSpan::set_mentiontype(const char* value) {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  mentiontype_->assign(value);
}
inline void NameSpan::set_mentiontype(const char* value, size_t size) {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  mentiontype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpan::mutable_mentiontype() {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  return mentiontype_;
}
inline ::std::string* NameSpan::release_mentiontype() {
  clear_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mentiontype_;
    mentiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameSpan::set_allocated_mentiontype(::std::string* mentiontype) {
  if (mentiontype_ != &::google::protobuf::internal::kEmptyString) {
    delete mentiontype_;
  }
  if (mentiontype) {
    set_has_mentiontype();
    mentiontype_ = mentiontype;
  } else {
    clear_has_mentiontype();
    mentiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string entityType = 2;
inline bool NameSpan::has_entitytype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameSpan::set_has_entitytype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameSpan::clear_has_entitytype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameSpan::clear_entitytype() {
  if (entitytype_ != &::google::protobuf::internal::kEmptyString) {
    entitytype_->clear();
  }
  clear_has_entitytype();
}
inline const ::std::string& NameSpan::entitytype() const {
  return *entitytype_;
}
inline void NameSpan::set_entitytype(const ::std::string& value) {
  set_has_entitytype();
  if (entitytype_ == &::google::protobuf::internal::kEmptyString) {
    entitytype_ = new ::std::string;
  }
  entitytype_->assign(value);
}
inline void NameSpan::set_entitytype(const char* value) {
  set_has_entitytype();
  if (entitytype_ == &::google::protobuf::internal::kEmptyString) {
    entitytype_ = new ::std::string;
  }
  entitytype_->assign(value);
}
inline void NameSpan::set_entitytype(const char* value, size_t size) {
  set_has_entitytype();
  if (entitytype_ == &::google::protobuf::internal::kEmptyString) {
    entitytype_ = new ::std::string;
  }
  entitytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpan::mutable_entitytype() {
  set_has_entitytype();
  if (entitytype_ == &::google::protobuf::internal::kEmptyString) {
    entitytype_ = new ::std::string;
  }
  return entitytype_;
}
inline ::std::string* NameSpan::release_entitytype() {
  clear_has_entitytype();
  if (entitytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entitytype_;
    entitytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameSpan::set_allocated_entitytype(::std::string* entitytype) {
  if (entitytype_ != &::google::protobuf::internal::kEmptyString) {
    delete entitytype_;
  }
  if (entitytype) {
    set_has_entitytype();
    entitytype_ = entitytype;
  } else {
    clear_has_entitytype();
    entitytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string entitySubtype = 3;
inline bool NameSpan::has_entitysubtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameSpan::set_has_entitysubtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameSpan::clear_has_entitysubtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameSpan::clear_entitysubtype() {
  if (entitysubtype_ != &::google::protobuf::internal::kEmptyString) {
    entitysubtype_->clear();
  }
  clear_has_entitysubtype();
}
inline const ::std::string& NameSpan::entitysubtype() const {
  return *entitysubtype_;
}
inline void NameSpan::set_entitysubtype(const ::std::string& value) {
  set_has_entitysubtype();
  if (entitysubtype_ == &::google::protobuf::internal::kEmptyString) {
    entitysubtype_ = new ::std::string;
  }
  entitysubtype_->assign(value);
}
inline void NameSpan::set_entitysubtype(const char* value) {
  set_has_entitysubtype();
  if (entitysubtype_ == &::google::protobuf::internal::kEmptyString) {
    entitysubtype_ = new ::std::string;
  }
  entitysubtype_->assign(value);
}
inline void NameSpan::set_entitysubtype(const char* value, size_t size) {
  set_has_entitysubtype();
  if (entitysubtype_ == &::google::protobuf::internal::kEmptyString) {
    entitysubtype_ = new ::std::string;
  }
  entitysubtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpan::mutable_entitysubtype() {
  set_has_entitysubtype();
  if (entitysubtype_ == &::google::protobuf::internal::kEmptyString) {
    entitysubtype_ = new ::std::string;
  }
  return entitysubtype_;
}
inline ::std::string* NameSpan::release_entitysubtype() {
  clear_has_entitysubtype();
  if (entitysubtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entitysubtype_;
    entitysubtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameSpan::set_allocated_entitysubtype(::std::string* entitysubtype) {
  if (entitysubtype_ != &::google::protobuf::internal::kEmptyString) {
    delete entitysubtype_;
  }
  if (entitysubtype) {
    set_has_entitysubtype();
    entitysubtype_ = entitysubtype;
  } else {
    clear_has_entitysubtype();
    entitysubtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string allMentions = 4;
inline int NameSpan::allmentions_size() const {
  return allmentions_.size();
}
inline void NameSpan::clear_allmentions() {
  allmentions_.Clear();
}
inline const ::std::string& NameSpan::allmentions(int index) const {
  return allmentions_.Get(index);
}
inline ::std::string* NameSpan::mutable_allmentions(int index) {
  return allmentions_.Mutable(index);
}
inline void NameSpan::set_allmentions(int index, const ::std::string& value) {
  allmentions_.Mutable(index)->assign(value);
}
inline void NameSpan::set_allmentions(int index, const char* value) {
  allmentions_.Mutable(index)->assign(value);
}
inline void NameSpan::set_allmentions(int index, const char* value, size_t size) {
  allmentions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpan::add_allmentions() {
  return allmentions_.Add();
}
inline void NameSpan::add_allmentions(const ::std::string& value) {
  allmentions_.Add()->assign(value);
}
inline void NameSpan::add_allmentions(const char* value) {
  allmentions_.Add()->assign(value);
}
inline void NameSpan::add_allmentions(const char* value, size_t size) {
  allmentions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NameSpan::allmentions() const {
  return allmentions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NameSpan::mutable_allmentions() {
  return &allmentions_;
}

// optional int32 start = 5;
inline bool NameSpan::has_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NameSpan::set_has_start() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NameSpan::clear_has_start() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NameSpan::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 NameSpan::start() const {
  return start_;
}
inline void NameSpan::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
}

// optional int32 end = 6;
inline bool NameSpan::has_end() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NameSpan::set_has_end() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NameSpan::clear_has_end() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NameSpan::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 NameSpan::end() const {
  return end_;
}
inline void NameSpan::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
}

// -------------------------------------------------------------------

// SentenceTheory

// optional string docid = 1;
inline bool SentenceTheory::has_docid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SentenceTheory::set_has_docid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SentenceTheory::clear_has_docid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SentenceTheory::clear_docid() {
  if (docid_ != &::google::protobuf::internal::kEmptyString) {
    docid_->clear();
  }
  clear_has_docid();
}
inline const ::std::string& SentenceTheory::docid() const {
  return *docid_;
}
inline void SentenceTheory::set_docid(const ::std::string& value) {
  set_has_docid();
  if (docid_ == &::google::protobuf::internal::kEmptyString) {
    docid_ = new ::std::string;
  }
  docid_->assign(value);
}
inline void SentenceTheory::set_docid(const char* value) {
  set_has_docid();
  if (docid_ == &::google::protobuf::internal::kEmptyString) {
    docid_ = new ::std::string;
  }
  docid_->assign(value);
}
inline void SentenceTheory::set_docid(const char* value, size_t size) {
  set_has_docid();
  if (docid_ == &::google::protobuf::internal::kEmptyString) {
    docid_ = new ::std::string;
  }
  docid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SentenceTheory::mutable_docid() {
  set_has_docid();
  if (docid_ == &::google::protobuf::internal::kEmptyString) {
    docid_ = new ::std::string;
  }
  return docid_;
}
inline ::std::string* SentenceTheory::release_docid() {
  clear_has_docid();
  if (docid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = docid_;
    docid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SentenceTheory::set_allocated_docid(::std::string* docid) {
  if (docid_ != &::google::protobuf::internal::kEmptyString) {
    delete docid_;
  }
  if (docid) {
    set_has_docid();
    docid_ = docid;
  } else {
    clear_has_docid();
    docid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string language = 2;
inline bool SentenceTheory::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SentenceTheory::set_has_language() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SentenceTheory::clear_has_language() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SentenceTheory::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& SentenceTheory::language() const {
  return *language_;
}
inline void SentenceTheory::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void SentenceTheory::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void SentenceTheory::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SentenceTheory::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* SentenceTheory::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SentenceTheory::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sentIndex = 3;
inline bool SentenceTheory::has_sentindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SentenceTheory::set_has_sentindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SentenceTheory::clear_has_sentindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SentenceTheory::clear_sentindex() {
  sentindex_ = 0;
  clear_has_sentindex();
}
inline ::google::protobuf::int32 SentenceTheory::sentindex() const {
  return sentindex_;
}
inline void SentenceTheory::set_sentindex(::google::protobuf::int32 value) {
  set_has_sentindex();
  sentindex_ = value;
}

// repeated string token = 4;
inline int SentenceTheory::token_size() const {
  return token_.size();
}
inline void SentenceTheory::clear_token() {
  token_.Clear();
}
inline const ::std::string& SentenceTheory::token(int index) const {
  return token_.Get(index);
}
inline ::std::string* SentenceTheory::mutable_token(int index) {
  return token_.Mutable(index);
}
inline void SentenceTheory::set_token(int index, const ::std::string& value) {
  token_.Mutable(index)->assign(value);
}
inline void SentenceTheory::set_token(int index, const char* value) {
  token_.Mutable(index)->assign(value);
}
inline void SentenceTheory::set_token(int index, const char* value, size_t size) {
  token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SentenceTheory::add_token() {
  return token_.Add();
}
inline void SentenceTheory::add_token(const ::std::string& value) {
  token_.Add()->assign(value);
}
inline void SentenceTheory::add_token(const char* value) {
  token_.Add()->assign(value);
}
inline void SentenceTheory::add_token(const char* value, size_t size) {
  token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SentenceTheory::token() const {
  return token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SentenceTheory::mutable_token() {
  return &token_;
}

// repeated string docEvent = 5;
inline int SentenceTheory::docevent_size() const {
  return docevent_.size();
}
inline void SentenceTheory::clear_docevent() {
  docevent_.Clear();
}
inline const ::std::string& SentenceTheory::docevent(int index) const {
  return docevent_.Get(index);
}
inline ::std::string* SentenceTheory::mutable_docevent(int index) {
  return docevent_.Mutable(index);
}
inline void SentenceTheory::set_docevent(int index, const ::std::string& value) {
  docevent_.Mutable(index)->assign(value);
}
inline void SentenceTheory::set_docevent(int index, const char* value) {
  docevent_.Mutable(index)->assign(value);
}
inline void SentenceTheory::set_docevent(int index, const char* value, size_t size) {
  docevent_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SentenceTheory::add_docevent() {
  return docevent_.Add();
}
inline void SentenceTheory::add_docevent(const ::std::string& value) {
  docevent_.Add()->assign(value);
}
inline void SentenceTheory::add_docevent(const char* value) {
  docevent_.Add()->assign(value);
}
inline void SentenceTheory::add_docevent(const char* value, size_t size) {
  docevent_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SentenceTheory::docevent() const {
  return docevent_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SentenceTheory::mutable_docevent() {
  return &docevent_;
}

// repeated string sentEvent = 6;
inline int SentenceTheory::sentevent_size() const {
  return sentevent_.size();
}
inline void SentenceTheory::clear_sentevent() {
  sentevent_.Clear();
}
inline const ::std::string& SentenceTheory::sentevent(int index) const {
  return sentevent_.Get(index);
}
inline ::std::string* SentenceTheory::mutable_sentevent(int index) {
  return sentevent_.Mutable(index);
}
inline void SentenceTheory::set_sentevent(int index, const ::std::string& value) {
  sentevent_.Mutable(index)->assign(value);
}
inline void SentenceTheory::set_sentevent(int index, const char* value) {
  sentevent_.Mutable(index)->assign(value);
}
inline void SentenceTheory::set_sentevent(int index, const char* value, size_t size) {
  sentevent_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SentenceTheory::add_sentevent() {
  return sentevent_.Add();
}
inline void SentenceTheory::add_sentevent(const ::std::string& value) {
  sentevent_.Add()->assign(value);
}
inline void SentenceTheory::add_sentevent(const char* value) {
  sentevent_.Add()->assign(value);
}
inline void SentenceTheory::add_sentevent(const char* value, size_t size) {
  sentevent_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SentenceTheory::sentevent() const {
  return sentevent_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SentenceTheory::mutable_sentevent() {
  return &sentevent_;
}

// repeated .learnit.NameSpan nameSpan = 7;
inline int SentenceTheory::namespan_size() const {
  return namespan_.size();
}
inline void SentenceTheory::clear_namespan() {
  namespan_.Clear();
}
inline const ::learnit::NameSpan& SentenceTheory::namespan(int index) const {
  return namespan_.Get(index);
}
inline ::learnit::NameSpan* SentenceTheory::mutable_namespan(int index) {
  return namespan_.Mutable(index);
}
inline ::learnit::NameSpan* SentenceTheory::add_namespan() {
  return namespan_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::NameSpan >&
SentenceTheory::namespan() const {
  return namespan_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::NameSpan >*
SentenceTheory::mutable_namespan() {
  return &namespan_;
}

// -------------------------------------------------------------------

// BestName

// optional double confidence = 1;
inline bool BestName::has_confidence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BestName::set_has_confidence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BestName::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BestName::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline double BestName::confidence() const {
  return confidence_;
}
inline void BestName::set_confidence(double value) {
  set_has_confidence();
  confidence_ = value;
}

// optional string mentionType = 2;
inline bool BestName::has_mentiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BestName::set_has_mentiontype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BestName::clear_has_mentiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BestName::clear_mentiontype() {
  if (mentiontype_ != &::google::protobuf::internal::kEmptyString) {
    mentiontype_->clear();
  }
  clear_has_mentiontype();
}
inline const ::std::string& BestName::mentiontype() const {
  return *mentiontype_;
}
inline void BestName::set_mentiontype(const ::std::string& value) {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  mentiontype_->assign(value);
}
inline void BestName::set_mentiontype(const char* value) {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  mentiontype_->assign(value);
}
inline void BestName::set_mentiontype(const char* value, size_t size) {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  mentiontype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BestName::mutable_mentiontype() {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  return mentiontype_;
}
inline ::std::string* BestName::release_mentiontype() {
  clear_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mentiontype_;
    mentiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BestName::set_allocated_mentiontype(::std::string* mentiontype) {
  if (mentiontype_ != &::google::protobuf::internal::kEmptyString) {
    delete mentiontype_;
  }
  if (mentiontype) {
    set_has_mentiontype();
    mentiontype_ = mentiontype;
  } else {
    clear_has_mentiontype();
    mentiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text = 3;
inline bool BestName::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BestName::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BestName::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BestName::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& BestName::text() const {
  return *text_;
}
inline void BestName::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void BestName::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void BestName::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BestName::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* BestName::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BestName::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Role

// optional string type = 1;
inline bool Role::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Role::type() const {
  return *type_;
}
inline void Role::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Role::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Role::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* Role::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool Role::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Role::value() const {
  return *value_;
}
inline void Role::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Role::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Role::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Role::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlotFiller

// optional int32 slot = 1;
inline bool SlotFiller::has_slot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlotFiller::set_has_slot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlotFiller::clear_has_slot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlotFiller::clear_slot() {
  slot_ = 0;
  clear_has_slot();
}
inline ::google::protobuf::int32 SlotFiller::slot() const {
  return slot_;
}
inline void SlotFiller::set_slot(::google::protobuf::int32 value) {
  set_has_slot();
  slot_ = value;
}

// optional string type = 2;
inline bool SlotFiller::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlotFiller::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlotFiller::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlotFiller::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& SlotFiller::type() const {
  return *type_;
}
inline void SlotFiller::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SlotFiller::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SlotFiller::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlotFiller::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* SlotFiller::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlotFiller::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 startToken = 3;
inline bool SlotFiller::has_starttoken() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlotFiller::set_has_starttoken() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlotFiller::clear_has_starttoken() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlotFiller::clear_starttoken() {
  starttoken_ = 0;
  clear_has_starttoken();
}
inline ::google::protobuf::int32 SlotFiller::starttoken() const {
  return starttoken_;
}
inline void SlotFiller::set_starttoken(::google::protobuf::int32 value) {
  set_has_starttoken();
  starttoken_ = value;
}

// optional int32 endToken = 4;
inline bool SlotFiller::has_endtoken() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlotFiller::set_has_endtoken() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlotFiller::clear_has_endtoken() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlotFiller::clear_endtoken() {
  endtoken_ = 0;
  clear_has_endtoken();
}
inline ::google::protobuf::int32 SlotFiller::endtoken() const {
  return endtoken_;
}
inline void SlotFiller::set_endtoken(::google::protobuf::int32 value) {
  set_has_endtoken();
  endtoken_ = value;
}

// optional int32 headStartToken = 5;
inline bool SlotFiller::has_headstarttoken() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlotFiller::set_has_headstarttoken() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlotFiller::clear_has_headstarttoken() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlotFiller::clear_headstarttoken() {
  headstarttoken_ = 0;
  clear_has_headstarttoken();
}
inline ::google::protobuf::int32 SlotFiller::headstarttoken() const {
  return headstarttoken_;
}
inline void SlotFiller::set_headstarttoken(::google::protobuf::int32 value) {
  set_has_headstarttoken();
  headstarttoken_ = value;
}

// optional int32 headEndToken = 6;
inline bool SlotFiller::has_headendtoken() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlotFiller::set_has_headendtoken() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlotFiller::clear_has_headendtoken() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlotFiller::clear_headendtoken() {
  headendtoken_ = 0;
  clear_has_headendtoken();
}
inline ::google::protobuf::int32 SlotFiller::headendtoken() const {
  return headendtoken_;
}
inline void SlotFiller::set_headendtoken(::google::protobuf::int32 value) {
  set_has_headendtoken();
  headendtoken_ = value;
}

// optional string mentionType = 7;
inline bool SlotFiller::has_mentiontype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlotFiller::set_has_mentiontype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlotFiller::clear_has_mentiontype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlotFiller::clear_mentiontype() {
  if (mentiontype_ != &::google::protobuf::internal::kEmptyString) {
    mentiontype_->clear();
  }
  clear_has_mentiontype();
}
inline const ::std::string& SlotFiller::mentiontype() const {
  return *mentiontype_;
}
inline void SlotFiller::set_mentiontype(const ::std::string& value) {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  mentiontype_->assign(value);
}
inline void SlotFiller::set_mentiontype(const char* value) {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  mentiontype_->assign(value);
}
inline void SlotFiller::set_mentiontype(const char* value, size_t size) {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  mentiontype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlotFiller::mutable_mentiontype() {
  set_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    mentiontype_ = new ::std::string;
  }
  return mentiontype_;
}
inline ::std::string* SlotFiller::release_mentiontype() {
  clear_has_mentiontype();
  if (mentiontype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mentiontype_;
    mentiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlotFiller::set_allocated_mentiontype(::std::string* mentiontype) {
  if (mentiontype_ != &::google::protobuf::internal::kEmptyString) {
    delete mentiontype_;
  }
  if (mentiontype) {
    set_has_mentiontype();
    mentiontype_ = mentiontype;
  } else {
    clear_has_mentiontype();
    mentiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text = 8;
inline bool SlotFiller::has_text() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SlotFiller::set_has_text() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SlotFiller::clear_has_text() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SlotFiller::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SlotFiller::text() const {
  return *text_;
}
inline void SlotFiller::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SlotFiller::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SlotFiller::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlotFiller::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SlotFiller::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlotFiller::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string seedString = 9;
inline bool SlotFiller::has_seedstring() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SlotFiller::set_has_seedstring() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SlotFiller::clear_has_seedstring() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SlotFiller::clear_seedstring() {
  if (seedstring_ != &::google::protobuf::internal::kEmptyString) {
    seedstring_->clear();
  }
  clear_has_seedstring();
}
inline const ::std::string& SlotFiller::seedstring() const {
  return *seedstring_;
}
inline void SlotFiller::set_seedstring(const ::std::string& value) {
  set_has_seedstring();
  if (seedstring_ == &::google::protobuf::internal::kEmptyString) {
    seedstring_ = new ::std::string;
  }
  seedstring_->assign(value);
}
inline void SlotFiller::set_seedstring(const char* value) {
  set_has_seedstring();
  if (seedstring_ == &::google::protobuf::internal::kEmptyString) {
    seedstring_ = new ::std::string;
  }
  seedstring_->assign(value);
}
inline void SlotFiller::set_seedstring(const char* value, size_t size) {
  set_has_seedstring();
  if (seedstring_ == &::google::protobuf::internal::kEmptyString) {
    seedstring_ = new ::std::string;
  }
  seedstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlotFiller::mutable_seedstring() {
  set_has_seedstring();
  if (seedstring_ == &::google::protobuf::internal::kEmptyString) {
    seedstring_ = new ::std::string;
  }
  return seedstring_;
}
inline ::std::string* SlotFiller::release_seedstring() {
  clear_has_seedstring();
  if (seedstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seedstring_;
    seedstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlotFiller::set_allocated_seedstring(::std::string* seedstring) {
  if (seedstring_ != &::google::protobuf::internal::kEmptyString) {
    delete seedstring_;
  }
  if (seedstring) {
    set_has_seedstring();
    seedstring_ = seedstring;
  } else {
    clear_has_seedstring();
    seedstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .learnit.Role role = 10;
inline int SlotFiller::role_size() const {
  return role_.size();
}
inline void SlotFiller::clear_role() {
  role_.Clear();
}
inline const ::learnit::Role& SlotFiller::role(int index) const {
  return role_.Get(index);
}
inline ::learnit::Role* SlotFiller::mutable_role(int index) {
  return role_.Mutable(index);
}
inline ::learnit::Role* SlotFiller::add_role() {
  return role_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::Role >&
SlotFiller::role() const {
  return role_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::Role >*
SlotFiller::mutable_role() {
  return &role_;
}

// optional .learnit.BestName bestName = 11;
inline bool SlotFiller::has_bestname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SlotFiller::set_has_bestname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SlotFiller::clear_has_bestname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SlotFiller::clear_bestname() {
  if (bestname_ != NULL) bestname_->::learnit::BestName::Clear();
  clear_has_bestname();
}
inline const ::learnit::BestName& SlotFiller::bestname() const {
  return bestname_ != NULL ? *bestname_ : *default_instance_->bestname_;
}
inline ::learnit::BestName* SlotFiller::mutable_bestname() {
  set_has_bestname();
  if (bestname_ == NULL) bestname_ = new ::learnit::BestName;
  return bestname_;
}
inline ::learnit::BestName* SlotFiller::release_bestname() {
  clear_has_bestname();
  ::learnit::BestName* temp = bestname_;
  bestname_ = NULL;
  return temp;
}
inline void SlotFiller::set_allocated_bestname(::learnit::BestName* bestname) {
  delete bestname_;
  bestname_ = bestname;
  if (bestname) {
    set_has_bestname();
  } else {
    clear_has_bestname();
  }
}

// optional string language = 12;
inline bool SlotFiller::has_language() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SlotFiller::set_has_language() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SlotFiller::clear_has_language() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SlotFiller::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& SlotFiller::language() const {
  return *language_;
}
inline void SlotFiller::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void SlotFiller::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void SlotFiller::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlotFiller::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* SlotFiller::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlotFiller::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Arg

// repeated int32 propChildId = 1;
inline int Arg::propchildid_size() const {
  return propchildid_.size();
}
inline void Arg::clear_propchildid() {
  propchildid_.Clear();
}
inline ::google::protobuf::int32 Arg::propchildid(int index) const {
  return propchildid_.Get(index);
}
inline void Arg::set_propchildid(int index, ::google::protobuf::int32 value) {
  propchildid_.Set(index, value);
}
inline void Arg::add_propchildid(::google::protobuf::int32 value) {
  propchildid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Arg::propchildid() const {
  return propchildid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Arg::mutable_propchildid() {
  return &propchildid_;
}

// optional string role = 2;
inline bool Arg::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Arg::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Arg::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Arg::clear_role() {
  if (role_ != &::google::protobuf::internal::kEmptyString) {
    role_->clear();
  }
  clear_has_role();
}
inline const ::std::string& Arg::role() const {
  return *role_;
}
inline void Arg::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void Arg::set_role(const char* value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void Arg::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Arg::mutable_role() {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  return role_;
}
inline ::std::string* Arg::release_role() {
  clear_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Arg::set_allocated_role(::std::string* role) {
  if (role_ != &::google::protobuf::internal::kEmptyString) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string lex = 3;
inline bool Arg::has_lex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Arg::set_has_lex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Arg::clear_has_lex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Arg::clear_lex() {
  if (lex_ != &::google::protobuf::internal::kEmptyString) {
    lex_->clear();
  }
  clear_has_lex();
}
inline const ::std::string& Arg::lex() const {
  return *lex_;
}
inline void Arg::set_lex(const ::std::string& value) {
  set_has_lex();
  if (lex_ == &::google::protobuf::internal::kEmptyString) {
    lex_ = new ::std::string;
  }
  lex_->assign(value);
}
inline void Arg::set_lex(const char* value) {
  set_has_lex();
  if (lex_ == &::google::protobuf::internal::kEmptyString) {
    lex_ = new ::std::string;
  }
  lex_->assign(value);
}
inline void Arg::set_lex(const char* value, size_t size) {
  set_has_lex();
  if (lex_ == &::google::protobuf::internal::kEmptyString) {
    lex_ = new ::std::string;
  }
  lex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Arg::mutable_lex() {
  set_has_lex();
  if (lex_ == &::google::protobuf::internal::kEmptyString) {
    lex_ = new ::std::string;
  }
  return lex_;
}
inline ::std::string* Arg::release_lex() {
  clear_has_lex();
  if (lex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lex_;
    lex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Arg::set_allocated_lex(::std::string* lex) {
  if (lex_ != &::google::protobuf::internal::kEmptyString) {
    delete lex_;
  }
  if (lex) {
    set_has_lex();
    lex_ = lex;
  } else {
    clear_has_lex();
    lex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 slot = 4;
inline int Arg::slot_size() const {
  return slot_.size();
}
inline void Arg::clear_slot() {
  slot_.Clear();
}
inline ::google::protobuf::int32 Arg::slot(int index) const {
  return slot_.Get(index);
}
inline void Arg::set_slot(int index, ::google::protobuf::int32 value) {
  slot_.Set(index, value);
}
inline void Arg::add_slot(::google::protobuf::int32 value) {
  slot_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Arg::slot() const {
  return slot_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Arg::mutable_slot() {
  return &slot_;
}

// -------------------------------------------------------------------

// Prop

// repeated .learnit.Arg arg = 1;
inline int Prop::arg_size() const {
  return arg_.size();
}
inline void Prop::clear_arg() {
  arg_.Clear();
}
inline const ::learnit::Arg& Prop::arg(int index) const {
  return arg_.Get(index);
}
inline ::learnit::Arg* Prop::mutable_arg(int index) {
  return arg_.Mutable(index);
}
inline ::learnit::Arg* Prop::add_arg() {
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::Arg >&
Prop::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::Arg >*
Prop::mutable_arg() {
  return &arg_;
}

// optional string kind = 2;
inline bool Prop::has_kind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Prop::set_has_kind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Prop::clear_has_kind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Prop::clear_kind() {
  if (kind_ != &::google::protobuf::internal::kEmptyString) {
    kind_->clear();
  }
  clear_has_kind();
}
inline const ::std::string& Prop::kind() const {
  return *kind_;
}
inline void Prop::set_kind(const ::std::string& value) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
}
inline void Prop::set_kind(const char* value) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
}
inline void Prop::set_kind(const char* value, size_t size) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  kind_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prop::mutable_kind() {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    kind_ = new ::std::string;
  }
  return kind_;
}
inline ::std::string* Prop::release_kind() {
  clear_has_kind();
  if (kind_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = kind_;
    kind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Prop::set_allocated_kind(::std::string* kind) {
  if (kind_ != &::google::protobuf::internal::kEmptyString) {
    delete kind_;
  }
  if (kind) {
    set_has_kind();
    kind_ = kind;
  } else {
    clear_has_kind();
    kind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string predicate = 3;
inline bool Prop::has_predicate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Prop::set_has_predicate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Prop::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Prop::clear_predicate() {
  if (predicate_ != &::google::protobuf::internal::kEmptyString) {
    predicate_->clear();
  }
  clear_has_predicate();
}
inline const ::std::string& Prop::predicate() const {
  return *predicate_;
}
inline void Prop::set_predicate(const ::std::string& value) {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::kEmptyString) {
    predicate_ = new ::std::string;
  }
  predicate_->assign(value);
}
inline void Prop::set_predicate(const char* value) {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::kEmptyString) {
    predicate_ = new ::std::string;
  }
  predicate_->assign(value);
}
inline void Prop::set_predicate(const char* value, size_t size) {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::kEmptyString) {
    predicate_ = new ::std::string;
  }
  predicate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prop::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::kEmptyString) {
    predicate_ = new ::std::string;
  }
  return predicate_;
}
inline ::std::string* Prop::release_predicate() {
  clear_has_predicate();
  if (predicate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = predicate_;
    predicate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Prop::set_allocated_predicate(::std::string* predicate) {
  if (predicate_ != &::google::protobuf::internal::kEmptyString) {
    delete predicate_;
  }
  if (predicate) {
    set_has_predicate();
    predicate_ = predicate;
  } else {
    clear_has_predicate();
    predicate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PatternMatch

// optional string target = 1;
inline bool PatternMatch::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PatternMatch::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PatternMatch::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PatternMatch::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& PatternMatch::target() const {
  return *target_;
}
inline void PatternMatch::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void PatternMatch::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void PatternMatch::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PatternMatch::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* PatternMatch::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PatternMatch::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pattern = 2;
inline bool PatternMatch::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PatternMatch::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PatternMatch::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PatternMatch::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::kEmptyString) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& PatternMatch::pattern() const {
  return *pattern_;
}
inline void PatternMatch::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
}
inline void PatternMatch::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
}
inline void PatternMatch::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PatternMatch::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  return pattern_;
}
inline ::std::string* PatternMatch::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PatternMatch::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::kEmptyString) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 startToken = 3;
inline bool PatternMatch::has_starttoken() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PatternMatch::set_has_starttoken() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PatternMatch::clear_has_starttoken() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PatternMatch::clear_starttoken() {
  starttoken_ = 0;
  clear_has_starttoken();
}
inline ::google::protobuf::int32 PatternMatch::starttoken() const {
  return starttoken_;
}
inline void PatternMatch::set_starttoken(::google::protobuf::int32 value) {
  set_has_starttoken();
  starttoken_ = value;
}

// optional int32 endToken = 4;
inline bool PatternMatch::has_endtoken() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PatternMatch::set_has_endtoken() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PatternMatch::clear_has_endtoken() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PatternMatch::clear_endtoken() {
  endtoken_ = 0;
  clear_has_endtoken();
}
inline ::google::protobuf::int32 PatternMatch::endtoken() const {
  return endtoken_;
}
inline void PatternMatch::set_endtoken(::google::protobuf::int32 value) {
  set_has_endtoken();
  endtoken_ = value;
}

// repeated .learnit.SlotFiller slot = 5;
inline int PatternMatch::slot_size() const {
  return slot_.size();
}
inline void PatternMatch::clear_slot() {
  slot_.Clear();
}
inline const ::learnit::SlotFiller& PatternMatch::slot(int index) const {
  return slot_.Get(index);
}
inline ::learnit::SlotFiller* PatternMatch::mutable_slot(int index) {
  return slot_.Mutable(index);
}
inline ::learnit::SlotFiller* PatternMatch::add_slot() {
  return slot_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller >&
PatternMatch::slot() const {
  return slot_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller >*
PatternMatch::mutable_slot() {
  return &slot_;
}

// -------------------------------------------------------------------

// SeedInstanceMatch

// optional string target = 1;
inline bool SeedInstanceMatch::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SeedInstanceMatch::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SeedInstanceMatch::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SeedInstanceMatch::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& SeedInstanceMatch::target() const {
  return *target_;
}
inline void SeedInstanceMatch::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void SeedInstanceMatch::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void SeedInstanceMatch::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SeedInstanceMatch::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* SeedInstanceMatch::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SeedInstanceMatch::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string relationMatch = 2;
inline int SeedInstanceMatch::relationmatch_size() const {
  return relationmatch_.size();
}
inline void SeedInstanceMatch::clear_relationmatch() {
  relationmatch_.Clear();
}
inline const ::std::string& SeedInstanceMatch::relationmatch(int index) const {
  return relationmatch_.Get(index);
}
inline ::std::string* SeedInstanceMatch::mutable_relationmatch(int index) {
  return relationmatch_.Mutable(index);
}
inline void SeedInstanceMatch::set_relationmatch(int index, const ::std::string& value) {
  relationmatch_.Mutable(index)->assign(value);
}
inline void SeedInstanceMatch::set_relationmatch(int index, const char* value) {
  relationmatch_.Mutable(index)->assign(value);
}
inline void SeedInstanceMatch::set_relationmatch(int index, const char* value, size_t size) {
  relationmatch_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SeedInstanceMatch::add_relationmatch() {
  return relationmatch_.Add();
}
inline void SeedInstanceMatch::add_relationmatch(const ::std::string& value) {
  relationmatch_.Add()->assign(value);
}
inline void SeedInstanceMatch::add_relationmatch(const char* value) {
  relationmatch_.Add()->assign(value);
}
inline void SeedInstanceMatch::add_relationmatch(const char* value, size_t size) {
  relationmatch_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SeedInstanceMatch::relationmatch() const {
  return relationmatch_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SeedInstanceMatch::mutable_relationmatch() {
  return &relationmatch_;
}

// repeated string eventMatch = 3;
inline int SeedInstanceMatch::eventmatch_size() const {
  return eventmatch_.size();
}
inline void SeedInstanceMatch::clear_eventmatch() {
  eventmatch_.Clear();
}
inline const ::std::string& SeedInstanceMatch::eventmatch(int index) const {
  return eventmatch_.Get(index);
}
inline ::std::string* SeedInstanceMatch::mutable_eventmatch(int index) {
  return eventmatch_.Mutable(index);
}
inline void SeedInstanceMatch::set_eventmatch(int index, const ::std::string& value) {
  eventmatch_.Mutable(index)->assign(value);
}
inline void SeedInstanceMatch::set_eventmatch(int index, const char* value) {
  eventmatch_.Mutable(index)->assign(value);
}
inline void SeedInstanceMatch::set_eventmatch(int index, const char* value, size_t size) {
  eventmatch_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SeedInstanceMatch::add_eventmatch() {
  return eventmatch_.Add();
}
inline void SeedInstanceMatch::add_eventmatch(const ::std::string& value) {
  eventmatch_.Add()->assign(value);
}
inline void SeedInstanceMatch::add_eventmatch(const char* value) {
  eventmatch_.Add()->assign(value);
}
inline void SeedInstanceMatch::add_eventmatch(const char* value, size_t size) {
  eventmatch_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SeedInstanceMatch::eventmatch() const {
  return eventmatch_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SeedInstanceMatch::mutable_eventmatch() {
  return &eventmatch_;
}

// repeated string eventAnchor = 4;
inline int SeedInstanceMatch::eventanchor_size() const {
  return eventanchor_.size();
}
inline void SeedInstanceMatch::clear_eventanchor() {
  eventanchor_.Clear();
}
inline const ::std::string& SeedInstanceMatch::eventanchor(int index) const {
  return eventanchor_.Get(index);
}
inline ::std::string* SeedInstanceMatch::mutable_eventanchor(int index) {
  return eventanchor_.Mutable(index);
}
inline void SeedInstanceMatch::set_eventanchor(int index, const ::std::string& value) {
  eventanchor_.Mutable(index)->assign(value);
}
inline void SeedInstanceMatch::set_eventanchor(int index, const char* value) {
  eventanchor_.Mutable(index)->assign(value);
}
inline void SeedInstanceMatch::set_eventanchor(int index, const char* value, size_t size) {
  eventanchor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SeedInstanceMatch::add_eventanchor() {
  return eventanchor_.Add();
}
inline void SeedInstanceMatch::add_eventanchor(const ::std::string& value) {
  eventanchor_.Add()->assign(value);
}
inline void SeedInstanceMatch::add_eventanchor(const char* value) {
  eventanchor_.Add()->assign(value);
}
inline void SeedInstanceMatch::add_eventanchor(const char* value, size_t size) {
  eventanchor_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SeedInstanceMatch::eventanchor() const {
  return eventanchor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SeedInstanceMatch::mutable_eventanchor() {
  return &eventanchor_;
}

// optional double score = 5;
inline bool SeedInstanceMatch::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SeedInstanceMatch::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SeedInstanceMatch::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SeedInstanceMatch::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline double SeedInstanceMatch::score() const {
  return score_;
}
inline void SeedInstanceMatch::set_score(double value) {
  set_has_score();
  score_ = value;
}

// repeated .learnit.SlotFiller slot = 6;
inline int SeedInstanceMatch::slot_size() const {
  return slot_.size();
}
inline void SeedInstanceMatch::clear_slot() {
  slot_.Clear();
}
inline const ::learnit::SlotFiller& SeedInstanceMatch::slot(int index) const {
  return slot_.Get(index);
}
inline ::learnit::SlotFiller* SeedInstanceMatch::mutable_slot(int index) {
  return slot_.Mutable(index);
}
inline ::learnit::SlotFiller* SeedInstanceMatch::add_slot() {
  return slot_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller >&
SeedInstanceMatch::slot() const {
  return slot_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::SlotFiller >*
SeedInstanceMatch::mutable_slot() {
  return &slot_;
}

// repeated .learnit.Prop prop = 7;
inline int SeedInstanceMatch::prop_size() const {
  return prop_.size();
}
inline void SeedInstanceMatch::clear_prop() {
  prop_.Clear();
}
inline const ::learnit::Prop& SeedInstanceMatch::prop(int index) const {
  return prop_.Get(index);
}
inline ::learnit::Prop* SeedInstanceMatch::mutable_prop(int index) {
  return prop_.Mutable(index);
}
inline ::learnit::Prop* SeedInstanceMatch::add_prop() {
  return prop_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::Prop >&
SeedInstanceMatch::prop() const {
  return prop_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::Prop >*
SeedInstanceMatch::mutable_prop() {
  return &prop_;
}

// optional string type = 8 [default = "seed"];
inline bool SeedInstanceMatch::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SeedInstanceMatch::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SeedInstanceMatch::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SeedInstanceMatch::clear_type() {
  if (type_ != _default_type_) {
    type_->assign(*_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& SeedInstanceMatch::type() const {
  return *type_;
}
inline void SeedInstanceMatch::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SeedInstanceMatch::set_type(const char* value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SeedInstanceMatch::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SeedInstanceMatch::mutable_type() {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string(*_default_type_);
  }
  return type_;
}
inline ::std::string* SeedInstanceMatch::release_type() {
  clear_has_type();
  if (type_ == _default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(_default_type_);
    return temp;
  }
}
inline void SeedInstanceMatch::set_allocated_type(::std::string* type) {
  if (type_ != _default_type_) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(_default_type_);
  }
}

// -------------------------------------------------------------------

// TokenAlignment

// optional int32 sourceIndex = 1;
inline bool TokenAlignment::has_sourceindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenAlignment::set_has_sourceindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TokenAlignment::clear_has_sourceindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TokenAlignment::clear_sourceindex() {
  sourceindex_ = 0;
  clear_has_sourceindex();
}
inline ::google::protobuf::int32 TokenAlignment::sourceindex() const {
  return sourceindex_;
}
inline void TokenAlignment::set_sourceindex(::google::protobuf::int32 value) {
  set_has_sourceindex();
  sourceindex_ = value;
}

// repeated int32 targetIndex = 2;
inline int TokenAlignment::targetindex_size() const {
  return targetindex_.size();
}
inline void TokenAlignment::clear_targetindex() {
  targetindex_.Clear();
}
inline ::google::protobuf::int32 TokenAlignment::targetindex(int index) const {
  return targetindex_.Get(index);
}
inline void TokenAlignment::set_targetindex(int index, ::google::protobuf::int32 value) {
  targetindex_.Set(index, value);
}
inline void TokenAlignment::add_targetindex(::google::protobuf::int32 value) {
  targetindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TokenAlignment::targetindex() const {
  return targetindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TokenAlignment::mutable_targetindex() {
  return &targetindex_;
}

// -------------------------------------------------------------------

// MentionAlignment

// optional .learnit.NameSpan sourceMention = 1;
inline bool MentionAlignment::has_sourcemention() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MentionAlignment::set_has_sourcemention() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MentionAlignment::clear_has_sourcemention() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MentionAlignment::clear_sourcemention() {
  if (sourcemention_ != NULL) sourcemention_->::learnit::NameSpan::Clear();
  clear_has_sourcemention();
}
inline const ::learnit::NameSpan& MentionAlignment::sourcemention() const {
  return sourcemention_ != NULL ? *sourcemention_ : *default_instance_->sourcemention_;
}
inline ::learnit::NameSpan* MentionAlignment::mutable_sourcemention() {
  set_has_sourcemention();
  if (sourcemention_ == NULL) sourcemention_ = new ::learnit::NameSpan;
  return sourcemention_;
}
inline ::learnit::NameSpan* MentionAlignment::release_sourcemention() {
  clear_has_sourcemention();
  ::learnit::NameSpan* temp = sourcemention_;
  sourcemention_ = NULL;
  return temp;
}
inline void MentionAlignment::set_allocated_sourcemention(::learnit::NameSpan* sourcemention) {
  delete sourcemention_;
  sourcemention_ = sourcemention;
  if (sourcemention) {
    set_has_sourcemention();
  } else {
    clear_has_sourcemention();
  }
}

// optional .learnit.NameSpan targetMention = 2;
inline bool MentionAlignment::has_targetmention() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MentionAlignment::set_has_targetmention() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MentionAlignment::clear_has_targetmention() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MentionAlignment::clear_targetmention() {
  if (targetmention_ != NULL) targetmention_->::learnit::NameSpan::Clear();
  clear_has_targetmention();
}
inline const ::learnit::NameSpan& MentionAlignment::targetmention() const {
  return targetmention_ != NULL ? *targetmention_ : *default_instance_->targetmention_;
}
inline ::learnit::NameSpan* MentionAlignment::mutable_targetmention() {
  set_has_targetmention();
  if (targetmention_ == NULL) targetmention_ = new ::learnit::NameSpan;
  return targetmention_;
}
inline ::learnit::NameSpan* MentionAlignment::release_targetmention() {
  clear_has_targetmention();
  ::learnit::NameSpan* temp = targetmention_;
  targetmention_ = NULL;
  return temp;
}
inline void MentionAlignment::set_allocated_targetmention(::learnit::NameSpan* targetmention) {
  delete targetmention_;
  targetmention_ = targetmention;
  if (targetmention) {
    set_has_targetmention();
  } else {
    clear_has_targetmention();
  }
}

// -------------------------------------------------------------------

// SentenceAlignment

// optional string source = 3;
inline bool SentenceAlignment::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SentenceAlignment::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SentenceAlignment::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SentenceAlignment::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& SentenceAlignment::source() const {
  return *source_;
}
inline void SentenceAlignment::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void SentenceAlignment::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void SentenceAlignment::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SentenceAlignment::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* SentenceAlignment::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SentenceAlignment::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target = 4;
inline bool SentenceAlignment::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SentenceAlignment::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SentenceAlignment::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SentenceAlignment::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& SentenceAlignment::target() const {
  return *target_;
}
inline void SentenceAlignment::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void SentenceAlignment::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void SentenceAlignment::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SentenceAlignment::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* SentenceAlignment::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SentenceAlignment::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .learnit.TokenAlignment tokenAlignment = 5;
inline int SentenceAlignment::tokenalignment_size() const {
  return tokenalignment_.size();
}
inline void SentenceAlignment::clear_tokenalignment() {
  tokenalignment_.Clear();
}
inline const ::learnit::TokenAlignment& SentenceAlignment::tokenalignment(int index) const {
  return tokenalignment_.Get(index);
}
inline ::learnit::TokenAlignment* SentenceAlignment::mutable_tokenalignment(int index) {
  return tokenalignment_.Mutable(index);
}
inline ::learnit::TokenAlignment* SentenceAlignment::add_tokenalignment() {
  return tokenalignment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::TokenAlignment >&
SentenceAlignment::tokenalignment() const {
  return tokenalignment_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::TokenAlignment >*
SentenceAlignment::mutable_tokenalignment() {
  return &tokenalignment_;
}

// repeated .learnit.MentionAlignment mentionAlignment = 6;
inline int SentenceAlignment::mentionalignment_size() const {
  return mentionalignment_.size();
}
inline void SentenceAlignment::clear_mentionalignment() {
  mentionalignment_.Clear();
}
inline const ::learnit::MentionAlignment& SentenceAlignment::mentionalignment(int index) const {
  return mentionalignment_.Get(index);
}
inline ::learnit::MentionAlignment* SentenceAlignment::mutable_mentionalignment(int index) {
  return mentionalignment_.Mutable(index);
}
inline ::learnit::MentionAlignment* SentenceAlignment::add_mentionalignment() {
  return mentionalignment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::MentionAlignment >&
SentenceAlignment::mentionalignment() const {
  return mentionalignment_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::MentionAlignment >*
SentenceAlignment::mutable_mentionalignment() {
  return &mentionalignment_;
}

// -------------------------------------------------------------------

// Sentence

// repeated .learnit.SentenceTheory sentenceTheory = 1;
inline int Sentence::sentencetheory_size() const {
  return sentencetheory_.size();
}
inline void Sentence::clear_sentencetheory() {
  sentencetheory_.Clear();
}
inline const ::learnit::SentenceTheory& Sentence::sentencetheory(int index) const {
  return sentencetheory_.Get(index);
}
inline ::learnit::SentenceTheory* Sentence::mutable_sentencetheory(int index) {
  return sentencetheory_.Mutable(index);
}
inline ::learnit::SentenceTheory* Sentence::add_sentencetheory() {
  return sentencetheory_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::SentenceTheory >&
Sentence::sentencetheory() const {
  return sentencetheory_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::SentenceTheory >*
Sentence::mutable_sentencetheory() {
  return &sentencetheory_;
}

// repeated .learnit.SentenceAlignment sentenceAlignment = 2;
inline int Sentence::sentencealignment_size() const {
  return sentencealignment_.size();
}
inline void Sentence::clear_sentencealignment() {
  sentencealignment_.Clear();
}
inline const ::learnit::SentenceAlignment& Sentence::sentencealignment(int index) const {
  return sentencealignment_.Get(index);
}
inline ::learnit::SentenceAlignment* Sentence::mutable_sentencealignment(int index) {
  return sentencealignment_.Mutable(index);
}
inline ::learnit::SentenceAlignment* Sentence::add_sentencealignment() {
  return sentencealignment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::SentenceAlignment >&
Sentence::sentencealignment() const {
  return sentencealignment_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::SentenceAlignment >*
Sentence::mutable_sentencealignment() {
  return &sentencealignment_;
}

// repeated .learnit.PatternMatch patternMatch = 3;
inline int Sentence::patternmatch_size() const {
  return patternmatch_.size();
}
inline void Sentence::clear_patternmatch() {
  patternmatch_.Clear();
}
inline const ::learnit::PatternMatch& Sentence::patternmatch(int index) const {
  return patternmatch_.Get(index);
}
inline ::learnit::PatternMatch* Sentence::mutable_patternmatch(int index) {
  return patternmatch_.Mutable(index);
}
inline ::learnit::PatternMatch* Sentence::add_patternmatch() {
  return patternmatch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::PatternMatch >&
Sentence::patternmatch() const {
  return patternmatch_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::PatternMatch >*
Sentence::mutable_patternmatch() {
  return &patternmatch_;
}

// repeated .learnit.SeedInstanceMatch seedInstanceMatch = 4;
inline int Sentence::seedinstancematch_size() const {
  return seedinstancematch_.size();
}
inline void Sentence::clear_seedinstancematch() {
  seedinstancematch_.Clear();
}
inline const ::learnit::SeedInstanceMatch& Sentence::seedinstancematch(int index) const {
  return seedinstancematch_.Get(index);
}
inline ::learnit::SeedInstanceMatch* Sentence::mutable_seedinstancematch(int index) {
  return seedinstancematch_.Mutable(index);
}
inline ::learnit::SeedInstanceMatch* Sentence::add_seedinstancematch() {
  return seedinstancematch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::SeedInstanceMatch >&
Sentence::seedinstancematch() const {
  return seedinstancematch_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::SeedInstanceMatch >*
Sentence::mutable_seedinstancematch() {
  return &seedinstancematch_;
}

// -------------------------------------------------------------------

// Instance

// repeated .learnit.Sentence sentence = 1;
inline int Instance::sentence_size() const {
  return sentence_.size();
}
inline void Instance::clear_sentence() {
  sentence_.Clear();
}
inline const ::learnit::Sentence& Instance::sentence(int index) const {
  return sentence_.Get(index);
}
inline ::learnit::Sentence* Instance::mutable_sentence(int index) {
  return sentence_.Mutable(index);
}
inline ::learnit::Sentence* Instance::add_sentence() {
  return sentence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::learnit::Sentence >&
Instance::sentence() const {
  return sentence_;
}
inline ::google::protobuf::RepeatedPtrField< ::learnit::Sentence >*
Instance::mutable_sentence() {
  return &sentence_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace learnit

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_instances_2eproto__INCLUDED
