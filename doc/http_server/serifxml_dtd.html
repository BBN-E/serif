
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
  <title>SerifXML DTD</title>
<style type="text/css">

body { 
    foreground: black;
    background: #777; 
}

div.body { 
    background: white; foreground: #000; 
    border: 2px solid black;
    margin: 1em 1em 0 1em;
    padding: 0.5em 1em;
}
h1 {
    font-size: 160%;
    text-align: center;
}

h2 {
    font-size: 140%;
}

div.section { 
    margin-top: 1em;
    padding: 0 20px;
}

div.section h3 {
    font-size: 130%;
    margin: 0.2em 0 0 -20px;
}

div.figure {
    width: 700px;
    margin: 1em auto 0 auto;
    text-align: center;
}

div.figure-image {
    border: 2px solid black;
    width: 600px;
    margin-left: auto; margin-right: auto;
    padding: 0.5em;
}

p.caption {
    text-align: left;
    margin-top: 0;
}

p.centered-caption {
    text-align: center;
    margin-top: 0;
}

div.indented {
    padding: 0 2em;
    margin: 0 0 1em 0;
}

pre.dtd {
    border: 1px solid black;
    padding: 0.5em;
    background: #def;
}

body.dtd div.body { padding-left: 40px; padding-right: 40px; }
body.dtd div.body h1 { margin-left: -20px; }
body.dtd div.body h2 { margin-left: -20px; }
div.dtd_item {
    background: #dfd;
    border: 1px solid black;
    padding: 0 1em;
    margin-bottom: 1em;
}
div.dtd_item h3 { 
    margin-top: 0;
}

span.ENTITY  { color: #800; }
span.ELEMENT { color: #800; font-weight: bold; }
span.ATTLIST { color: #800; }

hr.ELEMENT { 
    margin: 1em 0 0 0; border: 1px solid #9ab;
}

p.timestamp {
    text-align: right; margin: 0 2em; font-size: 90%;
}

pre.terminal {
    border: 1px solid black;
    padding: 0 0 0.5em 0.5em;
    background: #def;
}

pre.example-request {
    border: 1px solid black;
    padding: 0 0 0.5em 0.5em;
    background: #dfd;
    margin-bottom: 0;
    white-space: pre-wrap;
}
pre.example-response {
    border: 1px solid black;
    border-top: 0px;
    padding: 0 0 0.5em 0.5em;
    background: #fed;
    margin-top: 0;
    white-space: pre-wrap;
}
pre.example-response-error {
    border: 1px solid black;
    padding: 0.5em;
    background: #fed;
    white-space: pre-wrap;
}

pre div.label, pre div.http-example-label {
    float: right;
    border-left: 1px solid black;
    border-bottom: 1px solid black;
    padding: 0 0.5em;
    font-family: "Times New Roman", Times, serif; 
    font-size: 125%;
    font-weight: bold; 
}

pre.request-template {
    border: 1px solid black;
    padding: 0 0 0.5em 0.5em;
    background: #dfd;
}
pre.example-request div.label, pre.example-request div.http-example-label {
    background: #cec;
}
pre.example-response div.label, pre.example-response div.http-example-label {
    background: #edc;
}
pre.request-template div.label, pre.request-template div.http-example-label {
    background: #cec;
}
pre.terminal div.label {
    background: #bcd;
}

table {
    border-collapse:collapse;
}

table td {
    border: 1px solid black; background: #def;
    padding: 0 5px;
}

table th {
    border: 1px solid black; background: #bcd;
    padding: 0 5px;
}
table.options th { text-align: left; }

table td.noborder { border: 0px; background: inherit; }
table th.noborder { border: 0px; background: inherit; }

table.layout { border: 0px; padding: 0; margin: 0; }
table.layout td { border: 0px; padding: 0; margin: 0; background: inherit; }

div.example-session { 
    border: 1px solid black;
    background: #888;
    padding: 0 1em;
    margin: 1em;
}

div.in2out_example { 
    display: none; 
}

div.example-session h2 { margin-top: 0.2em; text-align: center; }

span.result-ellipsis { 
    font-family: "Times New Roman", Times, serif; 
    font-style: italic;
    font-weight: bold;
} 

span.comment { 
    font-family: "Times New Roman", Times, serif; 
    font-size: 110%;
    color: #060;
    font-weight: bold;
} 

span.var { 
/*    font-family: "Times New Roman", Times, serif; */
    font-style: italic;
    font-weight: bold;
    color: #860;
} 

span.changed {
    color: #080;
    font-weight: bold;
}

span.user-input { 
    font-weight: bold;
    color: #008;
}
span.prompt {
    font-weight: bold;
    color: #080;
}

pre.tree-leaf {
    padding: 0 1em; margin: 0;
    border: 1px solid black;
    background: #dfd;
    white-space: pre-wrap;
}

pre.tree-comment {
    padding: 0 1em; margin: 0;
    border: 1px solid black;
    background: #ddd;
    white-space: pre-wrap;
}

div.memory-usage {
    border: 1px solid black;
    width: 600px;
    padding: 0; margin: 0;
}

table.memory-usage {
    background: inherit;
    border-width: 0px;
    padding: 0; margin: 0;
}

table.memory-usage td {
    /*padding: 0; margin: 0; */
}

div.mu-crt-bar {
    float: left;
    background: #c80;
}

div.mu-normal-bar {
    float: left;
    background: #8c0;
}

table.memory-usage td.crt {
    background: #c80;
    border-width: 0px;
    overflow: hidden;
}

table.memory-usage td.normal {
    background: #8c0;
    border-width: 0px;
    overflow: hidden;
}

table.memory-usage td.blank {
    background: inherit;
    border-width: 0px;
    overflow: hidden;
}

/*
div.memory-usage {
    background: green;
    border: 1px solid black;
    width: 600px;
}

div.mu-size {
    position: absolute;
}

div.mu-normal-bar {
    float: left;
    background: #8c0;
}
div.mu-crt-bar {
    float: left;
    background: #c80;
}

div.mu-time {
    float: left;
    clear: both;
}

*/
body { 
    background: inherit; foreground: inherit;
}
</style>
</head>
<body class="dtd">
<div class="body">
<h1>SerifXML DTD, Version 0.8                     </h1>


<h2>1. Entity Definitions </h2>


<p>This section defines entities that are used by the DTD to
     represent attribute value types (eg <a href="#boolean">%boolean;</a>) and standard
     collections of attributes (eg <a href="#offsets.att">%offsets.att;</a>).</p>


<div class="dtd_item">
<h3>Attribute Value Types</h3>

<p>These entities are meant to document the type of value expected
     for various attributes.  In some cases (eg <a href="#number">%number;</a>), value types
     serve as documentation, but can not be checked by the DTD because
     of the limitations of DTDs.</p>


<p>Basic types:</p>


<a name="number"/>
<a name="boolean"/>
<pre class="dtd">
<span class="ENTITY">&lt;!ENTITY % <a href="#number">number</a>                        "CDATA"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#boolean">boolean</a>                       "(TRUE|FALSE)"&gt;</span></pre>

<p>Pointers to annotation layers</p>


<a name="region_ref"/>
<a name="token_sequence_ref"/>
<a name="part_of_speech_sequence_ref"/>
<a name="name_theory_ref"/>
<a name="value_mention_set_ref"/>
<a name="np_chunk_theory_ref"/>
<a name="parse_ref"/>
<a name="dependency_parse_ref"/>
<a name="mention_set_ref"/>
<a name="proposition_set_ref"/>
<a name="rel_mention_set_ref"/>
<a name="event_mention_set_ref"/>
<a name="event_ref"/>
<a name="value_ref"/>
<pre class="dtd">
<span class="ENTITY">&lt;!ENTITY % <a href="#region_ref">region_ref</a>                    "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#token_sequence_ref">token_sequence_ref</a>            "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#part_of_speech_sequence_ref">part_of_speech_sequence_ref</a>   "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#name_theory_ref">name_theory_ref</a>               "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#value_mention_set_ref">value_mention_set_ref</a>         "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#np_chunk_theory_ref">np_chunk_theory_ref</a>           "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#parse_ref">parse_ref</a>                     "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#dependency_parse_ref">dependency_parse_ref</a>          "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#mention_set_ref">mention_set_ref</a>               "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#proposition_set_ref">proposition_set_ref</a>           "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#rel_mention_set_ref">rel_mention_set_ref</a>           "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#event_mention_set_ref">event_mention_set_ref</a>         "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#event_ref">event_ref</a>                     "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#value_ref">value_ref</a>                     "IDREF"&gt;</span></pre>

<p>Pointers to annotation objects.  Note that <a href="#syn_node_ref">%syn_node_ref;</a> is
     defined as CDATA, rather than IDREF, to allow for pointers to
     automatically generated syntactic node identifiers.  See <a href="#Parse">&lt;Parse&gt;</a>
     and <a href="#TreebankString">&lt;TreebankString&gt;</a> for more information about automatically
     generated syntactic node ids.</p>


<a name="token_ref"/>
<a name="syn_node_ref"/>
<a name="mention_ref"/>
<a name="valmention_ref"/>
<a name="proposition_ref"/>
<a name="entity_ref"/>
<a name="rel_mention_ref"/>
<pre class="dtd">
<span class="ENTITY">&lt;!ENTITY % <a href="#token_ref">token_ref</a>                     "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#syn_node_ref">syn_node_ref</a>                  "CDATA"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#mention_ref">mention_ref</a>                   "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#valmention_ref">valmention_ref</a>                "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#proposition_ref">proposition_ref</a>               "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#entity_ref">entity_ref</a>                    "IDREF"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#rel_mention_ref">rel_mention_ref</a>               "IDREF"&gt;</span></pre>

<p>Space-separated lists of pointers to annotation objects.</p>


<a name="mention_ref_list"/>
<a name="rel_mention_ref_list"/>
<a name="event_mention_ref_list"/>
<a name="lexical_entry_ref_list"/>
<pre class="dtd">
<span class="ENTITY">&lt;!ENTITY % <a href="#mention_ref_list">mention_ref_list</a>              "IDREFS"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#rel_mention_ref_list">rel_mention_ref_list</a>          "IDREFS"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#event_mention_ref_list">event_mention_ref_list</a>        "IDREFS"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#lexical_entry_ref_list">lexical_entry_ref_list</a>        "IDREFS"&gt;</span></pre>

<p>Enumerated types.</p>


<a name="parse_type"/>
<a name="mention_type"/>
<a name="pred_type"/>
<a name="genericity"/>
<a name="polarity"/>
<a name="tense"/>
<a name="modality"/>
<pre class="dtd">
<span class="ENTITY">&lt;!ENTITY % <a href="#parse_type">parse_type</a>    "(full_parse|npchunk_parse)"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#mention_type">mention_type</a>  "(none|name|pron|desc|part|appo|list)"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#pred_type">pred_type</a>     "(verb|copula|modifier|noun|poss|
                           loc|set|name|pronoun|comp)"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#genericity">genericity</a>    "(Specific|Generic)"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#polarity">polarity</a>      "(Positive|Negative)"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#tense">tense</a>         "(Unspecified|Past|Present|Future)"&gt;</span>
<span class="ENTITY">&lt;!ENTITY % <a href="#modality">modality</a>      "(Asserted|Other)"&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#offsets.att">%offsets.att;</a> Attribute Entity</h3>

<p>Several annotations specify their location using "offset"
     pointers into the text of the original document.  This entity
     defines the attributes used to record offsets.</p>

<p>Serif is capable of generating three basic offset types, based on
     the text content of the document: byte offsets, character
     offsets, and EDT offsets.  (EDT offsets are an offset format used
     by ACE, which skips characters within XML tags, and treats
     Windows-style newlines as a single character.)  Begin and end
     offsets are zero-indexed, and both are inclusive (e.g., the
     character offset range with begin offset of 0 and end offset of 3
     specifies the first four characters in the document text).</p>

<p>When generating output files, Serif can be instructed to generate
     any or all of these offset types.  Serif can also be instructed
     to generate offsets using a either pair of attributes
     ("start_XXX" and "end_XXX"), or a single attribute whose value
     has the form "begin:end" ("XXX_offsets").  See the documentation
     for the serialization options "offset_types" and
     "condensed_offsets" for more information.</p>

<p>When reading input files, Serif requires that at least one of
     these three offset types be present, since it is possible to
     automatically convert between them (given the input document
     text).  When converting from character offsets to byte offsets,
     Serif assumes that the document is encoded using UTF-8.  The
     offsets can be expressed using either a pair of attributes
     ("start_XXX" and "end_XXX") or a single attribute
     ("XXX_offsets").</p>


<a name="offsets.att"/>
<pre class="dtd">
<span class="ENTITY">&lt;!ENTITY % <a href="#offsets.att">offsets.att</a>       "byte_offsets    CDATA    #IMPLIED
                              char_offsets    CDATA    #IMPLIED
                              edt_offsets     CDATA    #IMPLIED
                              start_byte      <a href="#number">%number;</a> #IMPLIED
                              end_byte        <a href="#number">%number;</a> #IMPLIED
                              start_char      <a href="#number">%number;</a> #IMPLIED
                              end_char        <a href="#number">%number;</a> #IMPLIED
                              start_edt       <a href="#number">%number;</a> #IMPLIED
                              end_edt         <a href="#number">%number;</a> #IMPLIED"&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#times.att">%times.att;</a> Attribute Entity</h3>

<p>For some documents, information may be available about the
     mapping between characters and times.  This entity defines
     the attributes used to express the span of times covered by
     a given annotation.</p>


<a name="times.att"/>
<pre class="dtd">
<span class="ENTITY">&lt;!ENTITY % <a href="#times.att">times.att</a>         "asr_times       CDATA    #IMPLIED
                              start_time      <a href="#number">%number;</a> #IMPLIED
                              end_time        <a href="#number">%number;</a> #IMPLIED"&gt;</span></pre>

</div>
<h2>2. Element Definitions</h2>


<p>Annotation elements are listed in the order in which they are
     typically generated by Serif.  (Note, however, that Serif may
     generate annotation layers in different orders, depending on the
     configuration parameters used when running it.)</p>


<div class="dtd_item">
<h3><a href="#SerifXML">&lt;SerifXML&gt;</a> Element</h3>

<p>Currently, Each SerifXML file can only contain a single document.  In
     the future, we may extend this to allow for multiple documents (but
     we would need to be careful not to allow XML identifier conflicts:
     each id needs to be unique in the entire SerifXML file.</p>


<a name="SerifXML"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#SerifXML">SerifXML</a> (<a href="#Document">Document</a>)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#SerifXML">SerifXML</a> version    CDATA    #IMPLIED&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#Document">&lt;Document&gt;</a> Element</h3>

<p>The <a href="#Document">&lt;Document&gt;</a> element contains the raw text contents of a
     document (or a URL pointing to the text contents), along with all
     of Serif's annotations for that document.  The minimal document
     includes a:</p>

         <ul>
           <li>A docid attribute (typically the filename).</li>
           <li>A language attribute, specifying what language the document is 
           written in.</li>
           <li>An <a href="#OriginalText">&lt;OriginalText&gt;</a> child element, containing either the original
           text or a pointer to the original text.</li>
         </ul>

<p>When Serif is run, it will generate additional elements and
     attributes describing the informational contents of the document:</p>

         <ul>
           <li>The <a href="#DateTime">&lt;DateTime&gt;</a> element contains the date/time substring from
           the document's headline (if appropriate - e.g., for newswire).</li>
           <li>The <a href="#Regions">&lt;Regions&gt;</a> element identifies substrings of the document
           that should be processed.  </li>
           <li>The <a href="#Metadata">&lt;Metadata&gt;</a> element records extra information about specific
           spans in the source document.  </li>
           <li>The <a href="#Sentences">&lt;Sentences&gt;</a> element identifies the locations of sentences
           in the document; and contains annotations for each sentence.</li>
           <li>The <a href="#EntitySet">&lt;EntitySet&gt;</a>, <a href="#ValueSet">&lt;ValueSet&gt;</a>, <a href="#RelationSet">&lt;RelationSet&gt;</a>, and <a href="#EventSet">&lt;EventSet&gt;</a>
           identify document-level entities/values/relations/events
           that were found SERIF.  Each of these objects contains a
           list of pointers to specific mentions.</li>
           <li>The <a href="#UTCoref">&lt;UTCoref&gt;</a> element is currently undocumented.</li>
           <li>The "source_type" attribute identifies what the genre of
           the document.  In ACE SGM documents, its value is extracted
           from the &lt;DOCTYPE&gt; element's "SOURCE" attribute or
           the &lt;DOC&gt; element's "genre" attribute.</li>
           <li>The "is_downcased" attribute will be set to true if the 
           entire document has been case-normalized to lower case.
           This is done for documents that do not have any case 
           information (e.g., when processing the output of a speech
           recognition system).</li>
         </ul>


<a name="Document"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#Document">Document</a>     (<a href="#OriginalText">OriginalText</a>, <a href="#DateTime">DateTime</a>?, <a href="#Regions">Regions</a>?, <a href="#Segments">Segments</a>?, 
                        <a href="#Metadata">Metadata</a>?, <a href="#Sentences">Sentences</a>?, <a href="#EntitySet">EntitySet</a>?, <a href="#ValueSet">ValueSet</a>?, 
                        <a href="#RelationSet">RelationSet</a>?, <a href="#EventSet">EventSet</a>?, <a href="#ValueMentionSet">ValueMentionSet</a>?, 
                        <a href="#RelMentionSet">RelMentionSet</a>?, <a href="#Lexicon">Lexicon</a>?,
                        <a href="#UTCoref">UTCoref</a>?)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Document">Document</a>     id              ID             #IMPLIED
                       docid           CDATA          #REQUIRED
                       language        CDATA          #REQUIRED
                       source_type     CDATA          "UNKNOWN"
                       is_downcased    <a href="#boolean">%boolean;</a>      "FALSE"&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#OriginalText">&lt;OriginalText&gt;</a> Element</h3>

<p>The <a href="#OriginalText">&lt;OriginalText&gt;</a> element supplies the original (unmodified)
     contents of the document.  The contents may either be listed
     inline, using a child <a href="#Contents">&lt;Contents&gt;</a> element, or identified by URL,
     using the "href" attribute.  </p>

<p>The command-line version of Serif supports "file://abspath" URLs.
     The server version supports both "file://abspath" and
     "http://server/path" URLs.</p>

<p>SERIF currently requires that all external files be encoded using
     UTF-8.</p>


<a name="OriginalText"/>
<a name="Contents"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#OriginalText">OriginalText</a>  (<a href="#Contents">Contents</a>?)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#OriginalText">OriginalText</a>  id              ID             #IMPLIED
                        href            CDATA          #IMPLIED
                        <a href="#offsets.att">%offsets.att;</a> <a href="#times.att">%times.att;</a>&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Contents">Contents</a> (#PCDATA)&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#Regions">&lt;Regions&gt;</a> Element</h3>

<p>Regions identify substrings within the document that we process.
     E.g., for broadcast news, each speaker's turn will be a separate
     region.  Regions are identified during the "zoning" stage. </p>

<p>The "tag" attribute identifies what kind of region this is.  For
     ACE SGM documents, the "tag" attribute comes from the XML tag of the
     element containing this region.  </p>

<p>The "is_speaker" and "is_receiver" attributes are used to identify
     two participants in a dialogue.  (SERIF does not currently have
     explicit support for multi-party dialogue.)</p>


<a name="Regions"/>
<a name="Region"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#Regions">Regions</a>       (<a href="#Region">Region</a>*)&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Region">Region</a>        (<a href="#Contents">Contents</a>?)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Region">Region</a>        id              ID             #IMPLIED
                        tag             CDATA          ""
                        is_speaker      <a href="#boolean">%boolean;</a>      "FALSE"
                        is_receiver     <a href="#boolean">%boolean;</a>      "FALSE"
                        <a href="#offsets.att">%offsets.att;</a> <a href="#times.att">%times.att;</a>&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#DateTime">&lt;DateTime&gt;</a> Element</h3>

<p>The location of the date/time substring from the document's
     headline (eg for newswire).  For ACE SGM documents, this is the
     contents of the &lt;DATETIME&gt; element. The <a href="#DateTime">&lt;DateTime&gt;</a> element is
     generated during the "zoning" stage.</p>


<a name="DateTime"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#DateTime">DateTime</a>      (<a href="#Contents">Contents</a>?)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#DateTime">DateTime</a>      id              ID             #IMPLIED
                        <a href="#offsets.att">%offsets.att;</a> <a href="#times.att">%times.att;</a>&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#Metadata">&lt;Metadata&gt;</a> Element</h3>

<p>A list of Spans, each of which define some property or properties
     for a substring of the original text.  Typically, this
     information is extracted from the XML structure of the source
     document (if it is an ACE SGM document).  Metadata spans are
     created during the "zoning" stage.</p>

     <ul>
       <li>*Note: the list of attributes may be incomplete.**</li>
     </ul>


<a name="Metadata"/>
<a name="Span"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#Metadata">Metadata</a>      (<a href="#Span">Span</a>*)&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Span">Span</a>          EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Span">Span</a>          id              ID             #IMPLIED
                        span_type       CDATA          #REQUIRED
                        region_type     CDATA          #IMPLIED
                        idf_type        CDATA          #IMPLIED
                        idf_role        CDATA          #IMPLIED
                        <a href="#offsets.att">%offsets.att;</a> <a href="#times.att">%times.att;</a>&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#Sentences">&lt;Sentences&gt;</a> Element</h3>

<p>Each <a href="#Sentence">&lt;Sentence&gt;</a> element identifies the location of a single
     sentence in the document; and contains Serif's sentence-level
     annotations for that sentence.  <a href="#Sentence">&lt;Sentence&gt;</a> elements are initially
     created by Serif's "sent-break" processing stage; and its child
     annotation elements are created in each of the following processing
     stages: "tokens", "part-of-speech", "names", "values", "parse", 
     "npchunk", "mentions", "props", "metonymy", "events", "relations".
     (Note: the order in which these stages may vary depending on the
     configuration parameters used to run SERIF.)</p>

<p>Each <a href="#Sentence">&lt;Sentence&gt;</a> element minimally consists of:</p>

         <ul>
           <li>Offset attributes, identifying the location of the sentence
           in the source document.</li>
           <li>A region identifier, identifying which region the sentence
           originates from.  ([XX] This attribute may become optional
           in the future, since it should be possible to reconstruct
           it automatically.)</li>
         </ul>

<p>Additionally, each <a href="#Sentence">&lt;Sentence&gt;</a> element may contain zero or more
     theories (i.e., possible values) for each annotation layer
     (TokenSequence, PartOfSpeechSequence, NameTheory, etc).</p>

<p>One or more <a href="#SentenceTheory">&lt;SentenceTheory&gt;</a> children can be used to specify
     which annotation layer theories form a complete (compatible)
     sentence theory.  If no <a href="#SentenceTheory">&lt;SentenceTheory&gt;</a> child is specified, then
     there should be at most one theory for each annotation layer; and
     they will automically be combined to form a single sentence
     theory.</p>

<p>The "primary_parse" attribute is only used if there is
     no <a href="#SentenceTheory">&lt;SentenceTheory&gt;</a> child.  In that case, it is used to specify
     which parse should be considered the primary parse for the
     implicit sentence theory.</p>

<p>[XX] The "is_annotated" attribute is currently undocumented.</p>


<a name="Sentences"/>
<a name="Sentence"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#Sentences">Sentences</a>       (<a href="#Sentence">Sentence</a>*)&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Sentence">Sentence</a>        (<a href="#Contents">Contents</a>?, 
                           (<a href="#TokenSequence">TokenSequence</a>|<a href="#PartOfSpeechSequence">PartOfSpeechSequence</a>|
                            <a href="#NameTheory">NameTheory</a>|<a href="#ValueMentionSet">ValueMentionSet</a>|
                            <a href="#NPChunkTheory">NPChunkTheory</a>|<a href="#Parse">Parse</a>|<a href="#DependencyParse">DependencyParse</a>|<a href="#MentionSet">MentionSet</a>|
                            <a href="#PropositionSet">PropositionSet</a>|<a href="#RelMentionSet">RelMentionSet</a>|
                            <a href="#EventMentionSet">EventMentionSet</a>|<a href="#SentenceTheory">SentenceTheory</a>)*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Sentence">Sentence</a>        id              ID             #IMPLIED
                          region_id       <a href="#region_ref">%region_ref;</a>   #REQUIRED
                          is_annotated    <a href="#boolean">%boolean;</a>      "TRUE"
                          primary_parse   <a href="#parse_type">%parse_type;</a>   "full_parse"
                          <a href="#offsets.att">%offsets.att;</a> <a href="#times.att">%times.att;</a>&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#SentenceTheory">&lt;SentenceTheory&gt;</a> Element</h3>

<p>Each <a href="#SentenceTheory">&lt;SentenceTheory&gt;</a> element specifies a collection of sentence-
     level annotation theories that form a complete (compatible)
     sentence theory.  This is only required when using a beam search
     that considers multiple annotation values during sentence
     processing.  Each <a href="#SentenceTheory">&lt;SentenceTheory&gt;</a> consists of a collection of 
     pointers to individual sentence-level annotation theories, along
     with an attribute ("primary_parse") used to identify whether the
     np chunk or the parse should be used as the basis for future 
     processing.</p>


<a name="SentenceTheory"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#SentenceTheory">SentenceTheory</a>  EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#SentenceTheory">SentenceTheory</a>  
   id                          ID                            #IMPLIED
   token_sequence_id           <a href="#token_sequence_ref">%token_sequence_ref;</a>          #IMPLIED
   part_of_speech_sequence_id  <a href="#part_of_speech_sequence_ref">%part_of_speech_sequence_ref;</a> #IMPLIED
   name_theory_id              <a href="#name_theory_ref">%name_theory_ref;</a>             #IMPLIED
   value_mention_set_id        <a href="#value_mention_set_ref">%value_mention_set_ref;</a>       #IMPLIED
   np_chunk_theory_id          <a href="#np_chunk_theory_ref">%np_chunk_theory_ref;</a>         #IMPLIED
   parse_id                    <a href="#parse_ref">%parse_ref;</a>                   #IMPLIED
   dependency_parse_id         <a href="#dependency_parse_ref">%dependency_parse_ref;</a>        #IMPLIED
   mention_set_id              <a href="#mention_set_ref">%mention_set_ref;</a>             #IMPLIED
   proposition_set_id          <a href="#proposition_set_ref">%proposition_set_ref;</a>         #IMPLIED
   rel_mention_set_id          <a href="#rel_mention_set_ref">%rel_mention_set_ref;</a>         #IMPLIED
   event_mention_set_id        <a href="#event_mention_set_ref">%event_mention_set_ref;</a>       #IMPLIED
   primary_parse               <a href="#parse_type">%parse_type;</a>                 "full_parse"&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#TokenSequence">&lt;TokenSequence&gt;</a> Element</h3>

<p>This annotation layer specifies the tokenization for a single
     sentence - i.e., how it should be divided into words.  It is
     generated during Serif's "tokens" processing stage.
     A <a href="#TokenSequence">&lt;TokenSequence&gt;</a> consists of an ordered sequence of <a href="#Token">&lt;Token&gt;</a>
     elements, along with an optional score attribute.  Each <a href="#Token">&lt;Token&gt;</a>
     element includes offset information that can be used to locate
     the token in the original docuemnt, along with the token's text.</p>

<p>If the serialization option "implicit_tokens" is set to true,
     then the string contents of a token will only be listed if it
     differs from the substring of the original text that it
     originated from.  (This can occur when Serif applies a variety of
     normalization rules.)</p>

<p>[XX] Note: In Arabic, <a href="#Token">&lt;Token&gt;</a> objects will include some extra
     attributes, which are not yet documented.</p>


<a name="TokenSequence"/>
<a name="Token"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#TokenSequence">TokenSequence</a>   (<a href="#Token">Token</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#TokenSequence">TokenSequence</a>   id                    ID            #IMPLIED
                          score                 <a href="#number">%number;</a>      #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Token">Token</a>           (#PCDATA)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Token">Token</a>           id                    ID            #IMPLIED
                          lexical_entries       <a href="#lexical_entry_ref_list">%lexical_entry_ref_list;</a> 
                                                              #IMPLIED
                          original_token_index  <a href="#number">%number;</a>      #IMPLIED
                          <a href="#offsets.att">%offsets.att;</a> <a href="#times.att">%times.att;</a>&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#PartOfSpeechSequence">&lt;PartOfSpeechSequence&gt;</a> Element</h3>

<p>This annotation layer specifies the part of speech for each word
     in a sentence.  It is generated by Serif's "part-of-speech"
     processing stage.  Each word's part of speech will be identified
     by a single <a href="#POS">&lt;POS&gt;</a> element, which uses a "token_id" attribute to
     point to a token, and a "tag" attribute to identify that token's
     most likely part-of-speech tag.</p>

<p>Depending on the configuration options used to run Serif, the
     <a href="#POS">&lt;POS&gt;</a> element may contain a "prob" element, specifying the
     probability of the most likely part-of-speech tag.  Additionally
     (depending on configuration options), one or more alternate
     part-of-speech tag possibilities may be listed,
     using <a href="#AlternatePOS">&lt;AlternatePOS&gt;</a> child elements.</p>

<p>The <a href="#PartOfSpeechSequence">&lt;PartOfSpeechSequence&gt;</a> element uses the "token_sequence_id"
     attribute to identify which token sequence it is based upon. 
     An optional "score" attributes indicates how likely it is that
     the part-of-speech sequence is correct.</p>

<p>Note: In Serif's default English configuration, the
     part-of-speech tagger is not actually run; instead, Serif uses
     the part of speech tags generated by the parser.  In this case,
     Serif will generate an empty <a href="#PartOfSpeechSequence">&lt;PartOfSpeechSequence&gt;</a> element.</p>


<a name="PartOfSpeechSequence"/>
<a name="POS"/>
<a name="AlternatePOS"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#PartOfSpeechSequence">PartOfSpeechSequence</a> (<a href="#POS">POS</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#PartOfSpeechSequence">PartOfSpeechSequence</a> 
                  id                  ID                     #IMPLIED
                  score               <a href="#number">%number;</a>               #IMPLIED
                  token_sequence_id   <a href="#token_sequence_ref">%token_sequence_ref;</a>   #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#POS">POS</a> (<a href="#AlternatePOS">AlternatePOS</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#POS">POS</a>
                  id                  ID                     #IMPLIED
                  tag                 CDATA                  #IMPLIED
                  prob                <a href="#number">%number;</a>               "1.0"
                  token_id            <a href="#token_ref">%token_ref;</a>            #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#AlternatePOS">AlternatePOS</a> EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#AlternatePOS">AlternatePOS</a>         
                  tag                 CDATA                  #REQUIRED
                  prob                <a href="#number">%number;</a>               #REQUIRED&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#NameTheory">&lt;NameTheory&gt;</a> Element</h3>

<p>This sentence-level annotation layer specifies the proper names
     that were found by SERIF's "names" processing stage.  Each proper
     name is identified as a range of tokens (where both start_token
     and end_token are inclusive), along with a basic entity type (e.g.,
     "PER" for person).</p>

<p>The <a href="#NameTheory">&lt;NameTheory&gt;</a> element uses the "token_sequence_id" attribute
     to identify which token sequence it is based upon.  An optional
     "score" attributes indicates how likely it is that the entire
     name theory is correct.</p>

<p>If the serialization option "include_name_transliterations"
     option is set to true, then a "transliteration" attribute will be
     generated for each name, containing an ASCII transliteration of
     that name.</p>

<p>Note: Currently, the start_token and end_token attributes are
     required.  If desired, we could add the option to specify names
     using offsets, rather than token indexes.</p>


<a name="NameTheory"/>
<a name="Name"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#NameTheory">NameTheory</a> (<a href="#Name">Name</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#NameTheory">NameTheory</a>
                  id                  ID                     #IMPLIED
                  score               <a href="#number">%number;</a>               #IMPLIED
                  token_sequence_id   <a href="#token_sequence_ref">%token_sequence_ref;</a>   #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Name">Name</a>    (#PCDATA)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Name">Name</a>    id                  ID                     #IMPLIED
                  entity_type         CDATA                  #REQUIRED
                  start_token         <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  end_token           <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  transliteration     CDATA                  #IMPLIED
                  score               <a href="#number">%number;</a>               #IMPLIED
                  <a href="#offsets.att">%offsets.att;</a> <a href="#times.att">%times.att;</a>&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#ValueMentionSet">&lt;ValueMentionSet&gt;</a> Element</h3>

<p>This annotation layer specifies the values (such as percentages,
     monetary values, phone numbers, time expressions, email
     addresses, and URLs) that were found by SERIF's "values"
     processing stage.  Each value is identified as a range of tokens
     (where both start_token and end_token are inclusive), and
     assigned a type (such as "TIMEX2.TIME").</p>


<a name="ValueMentionSet"/>
<a name="ValueMention"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#ValueMentionSet">ValueMentionSet</a> (<a href="#ValueMention">ValueMention</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#ValueMentionSet">ValueMentionSet</a>
                  id                  ID                     #IMPLIED
                  score               <a href="#number">%number;</a>               #IMPLIED
                  token_sequence_id   <a href="#token_sequence_ref">%token_sequence_ref;</a>   #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#ValueMention">ValueMention</a> (#PCDATA)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#ValueMention">ValueMention</a>
                  id                  ID                     #IMPLIED
                  start_token         <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  end_token           <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  value_type          CDATA                  #REQUIRED
                  sent_no             CDATA                  #IMPLIED
                  <a href="#offsets.att">%offsets.att;</a> <a href="#times.att">%times.att;</a>&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#NPChunkTheory">&lt;NPChunkTheory&gt;</a> Element</h3>

<p>This sentence-level annotation layer specifies the noun phrase
     chunks that were found by SERIF's "npchunk" processing stage.
     Each noun phrase chunk is identified as a range of tokens (where
     both start_token and end_token are inclusive).</p>


<a name="NPChunkTheory"/>
<a name="NPChunk"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#NPChunkTheory">NPChunkTheory</a> (<a href="#NPChunk">NPChunk</a>*, <a href="#Parse">Parse</a>?)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#NPChunkTheory">NPChunkTheory</a>
                  id                  ID                     #IMPLIED
                  score               <a href="#number">%number;</a>               #IMPLIED
                  token_sequence_id   <a href="#token_sequence_ref">%token_sequence_ref;</a>   #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#NPChunk">NPChunk</a> EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#NPChunk">NPChunk</a>
                  id                  ID                     #IMPLIED
                  start_token         <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  end_token           <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  <a href="#offsets.att">%offsets.att;</a> <a href="#times.att">%times.att;</a>&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#Parse">&lt;Parse&gt;</a> Element</h3>

<p>This sentence-level annotation layer records the syntactic tree
    generated by SERIF's "parse" processing stage.  The tree can be
    encoded in one of two ways: using nested <a href="#SynNode">&lt;SynNode&gt;</a> XML elements,
    or using a treebank-style parse string.  (Which encoding Serif
    uses for its output is controlled by the "parse_encoding"
    serialization option).</p>

<p>In the <a href="#SynNode">&lt;SynNode&gt;</a> encoding, the parse contains a single
    (root) <a href="#SynNode">&lt;SynNode&gt;</a>, each of which contains zero or more
    nested <a href="#SynNode">&lt;SynNode&gt;</a>s.  The terminals in this tree of <a href="#SynNode">&lt;SynNode&gt;</a>s
    correspond with individual words; and the preterminals are used to
    tag each word with its part-of-speech tag.  Nonterminals are used
    to encode syntactic constituents.</p>

<p>In the more compact <a href="#TreebankString">&lt;TreebankString&gt;</a> encoding,
    the <a href="#TreebankString">&lt;TreebankString&gt;</a> element contains a treebank-style parse
    string, where constituents are indicated using parenthasized
    expressions.  Head words are marked by appending the character "^"
    to their constituent tag.  The following example shows how the
    parse structure of a simple sentence is encoded:</p>

<pre>      &lt;Parse id="parse-2" score="-38.4776649" token_sequence_id="6"&gt;
        &lt;TreebankString node_id_method="DFS"&gt;
          (S^ (NPP (NNP^ joseph)) 
              (VP^ (VBZ^ likes) (VP (VBN^ fried) (NPA (NN^ zucchinis)))) 
              (. .))
        &lt;/TreebankString&gt;
      &lt;/Parse&gt;</pre>

<p>In order to allow other elements to refer to individual
    constituents in the parse tree, the syntactic nodes are
    automatically assigned identifiers.  These identifiers have the
    form: "<i>parse_id</i>-N", where "<i>parse_id</i>" is the identifier for the
    <a href="#Parse">&lt;Parse&gt;</a> element; and "N" is a number.  If the <a href="#TreebankString">&lt;TreebankString&gt;</a>'s
    "node_id_method" attribute is "DFS" (currently the only supported
    value), then N is generated by a depth-first enumeration of the
    syntactic nodes in the tree (including the token terminals).  For
    example, in the above tree, the identifier for the root "S" node
    is "parse-2-0"; and the identifier for the verb phrase node is
    "parse-2-4".</p>


<a name="Parse"/>
<a name="SynNode"/>
<a name="TreebankString"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#Parse">Parse</a>   (<a href="#SynNode">SynNode</a>|<a href="#TreebankString">TreebankString</a>)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Parse">Parse</a>   id                  ID                     #IMPLIED
                  score               <a href="#number">%number;</a>               #IMPLIED
                  token_sequence_id   <a href="#token_sequence_ref">%token_sequence_ref;</a>   #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#SynNode">SynNode</a> (<a href="#SynNode">SynNode</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#SynNode">SynNode</a> id                  ID                     #IMPLIED
                  tag                 CDATA                  #REQUIRED
                  start_token         <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  end_token           <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  is_head             <a href="#boolean">%boolean;</a>              "FALSE"&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#TreebankString">TreebankString</a> (#PCDATA)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#TreebankString">TreebankString</a> node_id_method CDATA                #FIXED "DFS"&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#DependencyParse">&lt;DependencyParse&gt;</a> Element</h3>

<p>A dependency parse consists of a tree of DepNodes.  Currently in development.
    Each node in the tree is a token in the sentence, tags express the relation a
    child node has to its parent.</p>


<a name="DependencyParse"/>
<a name="DepNode"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#DependencyParse">DependencyParse</a>   (<a href="#DepNode">DepNode</a>)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#DependencyParse">DependencyParse</a>   id                  ID                     #IMPLIED
                            score               <a href="#number">%number;</a>               #IMPLIED
                            token_sequence_id   <a href="#token_sequence_ref">%token_sequence_ref;</a>   #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#DepNode">DepNode</a> (<a href="#DepNode">DepNode</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#DepNode">DepNode</a> id                  ID                     #IMPLIED
                  tag                 CDATA                  #REQUIRED
                  start_token         <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  end_token           <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  token_id            <a href="#token_ref">%token_ref;</a>            #REQUIRED
                  pos                 CDATA                  #REQUIRED
                  text                CDATA                  #REQUIRED
                  &gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#MentionSet">&lt;MentionSet&gt;</a> Element</h3>

<p>This sentence-level annotation layer specifies the mentions (aka
    AnnotatedNPs) that were identified by Serif's "mentions"
    processing stage.  Two scores are generated by serif: "name_score"
    indicates the likelihood that Serif correctly identified the names
    in the sentence; and "desc_score" indicates the likelihood that Serif
    correctly identified the nominal descriptions.</p>

<p>Each <a href="#Mention">&lt;Mention&gt;</a> corresponds with a single NP node from the syntactic
    tree, identified by the "syn_node_id" attribute.  In addition, each
    mention is characterized by:</p>

        <ul>
          <li>A "mention_type" attribute, identifying whether the mention
          is a name, pronoun, nominal description, or is a nested
          partitive, appositive, or list mention.</li>
          <li>An "entity_type" attribute, identifying what kind of entity
          the mention describes (e.g., "PER" for person).</li>
          <li>An optional "entity_subtype" attribute, identifying a subtype
          for the basic entity type, or "UNDET" for undetermined.</li>
          <li>An "is_metonymy" attribute, used to identify whether this is
          a metonymous mention.  If so, then the "role_type" attribute
          is used to indicate the metonymy role, and the "intended_type"
          attribute is used to indicate the intended type. </li>
          <li>A "confidence_score" attribute, used to indicate how likely
          it is that this mention is in fact a mention of the given
          type and subtype.</li>
          <li>A "link_confidence" attribute, used to indicate how likely
          it is that this mention is in the correct entity (for entity
          coreference; see <a href="#Entity">&lt;Entity&gt;</a>). The "link_confidence2" attribute
          is used to store a variant of the same value.  </li>
          <li>Three attributes containing pointers to other mentions (parent, 
          child, and next) that are used to record the structure of 
          nested mentions (partitives, appositives, and lists).</li>
        </ul>


<a name="MentionSet"/>
<a name="Mention"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#MentionSet">MentionSet</a>      (<a href="#Mention">Mention</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#MentionSet">MentionSet</a>      id                  ID               #IMPLIED
                          name_score          <a href="#number">%number;</a>         #IMPLIED
                          desc_score          <a href="#number">%number;</a>         #IMPLIED
                          parse_id            <a href="#parse_ref">%parse_ref;</a>      #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Mention">Mention</a>         EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Mention">Mention</a>         id                  ID               #IMPLIED
                          syn_node_id         <a href="#syn_node_ref">%syn_node_ref;</a>   #REQUIRED
                          <a href="#mention_type">mention_type</a>        <a href="#mention_type">%mention_type;</a>   #REQUIRED
                          entity_type         CDATA            #REQUIRED
                          entity_subtype      CDATA            "UNDET"
                          is_metonymy         <a href="#boolean">%boolean;</a>        "FALSE"
                          intended_type       CDATA            "UNDET"
                          role_type           CDATA            "UNDET"
                          confidence_score    <a href="#number">%number;</a>         "1.0"
                          link_confidence     <a href="#number">%number;</a>         "1.0"
                          link_confidence2    <a href="#number">%number;</a>         "1.0"
                          parent              <a href="#mention_ref">%mention_ref;</a>    #IMPLIED
                          child               <a href="#mention_ref">%mention_ref;</a>    #IMPLIED
                          next                <a href="#mention_ref">%mention_ref;</a>    #IMPLIED&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#PropositionSet">&lt;PropositionSet&gt;</a> Element</h3>

<p>This sentence-level annotation layer specifies the propositions
    that were identified by Serif's "props" processing stage.</p>

<p>Each proposition has a type and one or more arguments.  Most
    propositions also have a head syntacic node, identified by the
    "head_id" attribute, which was used to create the proposition.
    A proposition may also optionally contain pointers to syntactic 
    nodes for an associated particle, adverb, negation, and modal.</p>

<p>Each proposition argument has a "role" attribute, identifying how
    it relates to the proposition, and points to either a mention,
    a syntactic node, or another proposition.</p>


<a name="PropositionSet"/>
<a name="Proposition"/>
<a name="Argument"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#PropositionSet">PropositionSet</a>  (<a href="#Proposition">Proposition</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#PropositionSet">PropositionSet</a>  id               ID                #IMPLIED
                          mention_set_id   <a href="#mention_set_ref">%mention_set_ref;</a> #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Proposition">Proposition</a>     (<a href="#Argument">Argument</a>+)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Proposition">Proposition</a>     id               ID                #IMPLIED
                          type             <a href="#pred_type">%pred_type;</a>       #REQUIRED
                          status           CDATA             #IMPLIED
                          head_id          <a href="#syn_node_ref">%syn_node_ref;</a>    #IMPLIED
                          particle_id      <a href="#syn_node_ref">%syn_node_ref;</a>    #IMPLIED
                          adverb_id        <a href="#syn_node_ref">%syn_node_ref;</a>    #IMPLIED
                          negation_id      <a href="#syn_node_ref">%syn_node_ref;</a>    #IMPLIED
                          modal_id         <a href="#syn_node_ref">%syn_node_ref;</a>    #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Argument">Argument</a>        EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Argument">Argument</a>        role             CDATA             ""
                          mention_id       <a href="#mention_ref">%mention_ref;</a>     #IMPLIED
                          syn_node_id      <a href="#syn_node_ref">%syn_node_ref;</a>    #IMPLIED
                          proposition_id   <a href="#proposition_ref">%proposition_ref;</a> #IMPLIED&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#RelMentionSet">&lt;RelMentionSet&gt;</a> Element</h3>

<p>This sentence-level annotation layer specifies the relation 
    mentions that were identified by Serif's "relations" stage.</p>

<p>Each relation mention has a relation type and two arguments.  The
    arguments are specified using the "left_mention_id" and
    "right_mention_id" attributes, both of which point to a <a href="#Mention">&lt;Mention&gt;</a>
    element.  An optional time argument may also be specified, using
    the "time_arg_id" attribute (which points to a <a href="#ValueMention">&lt;ValueMention&gt;</a>
    element).</p>


<a name="RelMentionSet"/>
<a name="RelMention"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#RelMentionSet">RelMentionSet</a>   (<a href="#RelMention">RelMention</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#RelMentionSet">RelMentionSet</a>   id                ID               #IMPLIED
                          score             <a href="#number">%number;</a>         #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#RelMention">RelMention</a>      EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#RelMention">RelMention</a>      id                ID               #IMPLIED
                          score             <a href="#number">%number;</a>         "1.0"
                          confidence_score  <a href="#number">%number;</a>         "1.0"
                          type              CDATA            #REQUIRED
                          raw_type          CDATA            #IMPLIED
                          <a href="#tense">tense</a>             <a href="#tense">%tense;</a>          #REQUIRED
                          <a href="#modality">modality</a>          <a href="#modality">%modality;</a>       #REQUIRED
                          left_mention_id   <a href="#mention_ref">%mention_ref;</a>    #REQUIRED
                          right_mention_id  <a href="#mention_ref">%mention_ref;</a>    #REQUIRED
                          time_arg_id       <a href="#valmention_ref">%valmention_ref;</a> #IMPLIED
                          time_arg_role     CDATA            #IMPLIED
                          time_arg_score    <a href="#number">%number;</a>         "0.0"&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#EventMentionSet">&lt;EventMentionSet&gt;</a> Element</h3>

<p>This sentence-level annotation layer specifies the event mentions
    that were identified by Serif's "events" stage.</p>


<a name="EventMentionSet"/>
<a name="EventMention"/>
<a name="EventMentionArg"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#EventMentionSet">EventMentionSet</a> (<a href="#EventMention">EventMention</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#EventMentionSet">EventMentionSet</a> id                ID                #IMPLIED
                          parse_id          <a href="#parse_ref">%parse_ref;</a>       #REQUIRED
                          score             <a href="#number">%number;</a>          #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#EventMention">EventMention</a>    (<a href="#EventMentionArg">EventMentionArg</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#EventMention">EventMention</a>    id                ID                #IMPLIED
                          pattern_id        CDATA             #IMPLIED
                          score             <a href="#number">%number;</a>          "0.0"
                          event_type        CDATA             #REQUIRED
                          <a href="#genericity">genericity</a>        <a href="#genericity">%genericity;</a>      #REQUIRED
                          <a href="#polarity">polarity</a>          <a href="#polarity">%polarity;</a>        #REQUIRED
                          <a href="#tense">tense</a>             <a href="#tense">%tense;</a>           #REQUIRED
                          <a href="#modality">modality</a>          <a href="#modality">%modality;</a>        #REQUIRED
                          anchor_prop_id    <a href="#proposition_ref">%proposition_ref;</a> #IMPLIED
                          anchor_node_id    <a href="#syn_node_ref">%syn_node_ref;</a>    #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#EventMentionArg">EventMentionArg</a> EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#EventMentionArg">EventMentionArg</a> mention_id        <a href="#mention_ref">%mention_ref;</a>     #IMPLIED
                          value_mention_id  <a href="#valmention_ref">%valmention_ref;</a>  #IMPLIED
                          role              CDATA             #REQUIRED
                          score             <a href="#number">%number;</a>          "0.0"
                          start_token         <a href="#token_ref">%token_ref;</a>     #IMPLIED
                          end_token           <a href="#token_ref">%token_ref;</a>     #IMPLIED
                          <a href="#offsets.att">%offsets.att;</a>&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#EntitySet">&lt;EntitySet&gt;</a> Element</h3>

<p>This document-level annotation layer records the entities that
    were found by Serif's "doc-entities" processing stage.  Each
    entity consists of a collection of coreferential <a href="#Mention">&lt;Mention&gt;</a>
    elements, which are identified using the "mention_ids" attribute.
    In addition, each <a href="#Entity">&lt;Entity&gt;</a> defines the following attributes:</p>

      <ul>
        <li>"entity_type": identifies the general category that the entity
        belongs to (e.g., "PER" for person).</li>
        <li>"entity_subtype": indentifies a subtype
        for the basic entity type, or "UNDET" for undetermined.</li>
        <li>"is_generic": True if this is a "generic" entity (such as
        "tall men"); false if this is a "specific" entity (such as
        "the tall man".</li>
        <li>"canonical_name": An optional string containing Serif's best
        guess at a canonical name for this entity.</li>
        <li>"entity_guid": An optional cross-document globally unique 
        identifier for this entity.  This attribute is only generated
        if cross-document coreference is enabled.</li>
        <li>"canonical_name_mention_id": If the serialization option
        "include_canonical_names" is set to true, then this attribute
        will identify the single best canonical <a href="#Mention">&lt;Mention&gt;</a>.</li>
        <li>"canonical_name_transliteration": If the serialization options
        "include_canonical_names" and "include_name_transliterations"
        are set to true, then an ASCII transliaterion of the canonical
        name <a href="#Mention">&lt;Mention&gt;</a> will be generated.</li>
        <li>"confidence_score": provides an estimated confidence score for
        the entity.</li>
      </ul>


<a name="EntitySet"/>
<a name="Entity"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#EntitySet">EntitySet</a>     (<a href="#Entity">Entity</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#EntitySet">EntitySet</a>  
            id                               ID                 #IMPLIED
            score                            <a href="#number">%number;</a>           #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Entity">Entity</a>     EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Entity">Entity</a>     
            id                               ID                 #IMPLIED
            mention_ids                      <a href="#mention_ref_list">%mention_ref_list;</a> #REQUIRED
            entity_type                      CDATA              #REQUIRED
            entity_subtype                   CDATA              "UNDET"
            is_generic                       <a href="#boolean">%boolean;</a>          #REQUIRED
            canonical_name                   CDATA              #IMPLIED
            entity_guid                      CDATA              "-1"
            canonical_name_mention_id        <a href="#mention_ref">%mention_ref;</a>      #IMPLIED
            canonical_name_transliteration   CDATA              #IMPLIED
            confidence_score                 <a href="#number">%number;</a>           "1.0"&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#ValueSet">&lt;ValueSet&gt;</a> Element</h3>

<p>This document-level annotation layer contains the values that were
    identified by Serif's "doc-values" stage.  Each value consists of
    a pointer to a single value mention, identified by the
    "value_mention_ref" attribute; a value type (which should
    typically match the type of the referenced value mention); and
    several optional attributes that are used to record information
    extracted from time values:</p>

      <ul>
        <li>"timex_val":</li>
        <li>"timex_anchor_val":</li>
        <li>"timex_anchor_dir":</li>
        <li>"timex_set":</li>
        <li>"timex_mod":</li>
        <li>"timex_non_specific":</li>
      </ul>


<a name="ValueSet"/>
<a name="Value"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#ValueSet">ValueSet</a>      (<a href="#Value">Value</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#ValueSet">ValueSet</a>      id                  ID                #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Value">Value</a>         EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Value">Value</a>         id                  ID                #IMPLIED
                        type                CDATA             #REQUIRED
                        value_mention_ref   <a href="#valmention_ref">%valmention_ref;</a>  #REQUIRED
                        timex_val           CDATA             #IMPLIED
                        timex_anchor_val    CDATA             #IMPLIED
                        timex_anchor_dir    CDATA             #IMPLIED
                        timex_set           CDATA             #IMPLIED
                        timex_mod           CDATA             #IMPLIED
                        timex_non_specific  CDATA             #IMPLIED&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#RelationSet">&lt;RelationSet&gt;</a> Element</h3>

<p>This document-level annotation layer records the set of relations
    that were identified by Serif's "doc-relations-events" stage.
    Each relation consists of a collection of coreferential <a href="#RelMention">&lt;RelMention&gt;</a>
    elements, which are identified using the "rel_mention_ids" attribute.</p>

<p>Each <a href="#Relation">&lt;Relation&gt;</a> has a relation type and two entity arguments.  The
    arguments are specified using the "left_entity_id" and
    "right_entity_id" attributes, both of which point to an <a href="#Entity">&lt;Entity&gt;</a>
    element.</p>

<p>The "tense" and "modality" attributes are computed by combining
    the corresponding values from the individual event mentions.</p>

<p>The "confidence" and "confidence_score" attributes provide 
    estimated confidence scores for the relation.</p>


<a name="RelationSet"/>
<a name="Relation"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#RelationSet">RelationSet</a>   (<a href="#Relation">Relation</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#RelationSet">RelationSet</a>   id                ID                     #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Relation">Relation</a>      EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Relation">Relation</a>      id                ID                     #IMPLIED
                        rel_mention_ids   <a href="#rel_mention_ref_list">%rel_mention_ref_list;</a> #REQUIRED
                        type              CDATA                  #REQUIRED
                        left_entity_id    <a href="#entity_ref">%entity_ref;</a>           #REQUIRED
                        right_entity_id   <a href="#entity_ref">%entity_ref;</a>           #REQUIRED
                        <a href="#tense">tense</a>             <a href="#tense">%tense;</a>                #REQUIRED
                        <a href="#modality">modality</a>          <a href="#modality">%modality;</a>             #REQUIRED
                        confidence        <a href="#number">%number;</a>               "1.0"
                        confidence_score  <a href="#number">%number;</a>               "1.0"&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#EventSet">&lt;EventSet&gt;</a> Element</h3>

<p>This document-level annotation layer records the set of events
    that were identified by Serif's "doc-relations-events" stage.
    Each event consists of a collection of
    coreferential <a href="#EventMention">&lt;EventMention&gt;</a> elements, which are identified using
    the "event_mention_ids" attribute.  In addition, each <a href="#Event">&lt;Event&gt;</a>
    defines the following attributes:</p>

      <ul>
        <li>"event_type": The kind of event described (e.g., "Life.Born"
        or "Contact.Meet").</li>
        <li>"genericity", "polarity", "tense", and "modality": These
        attributes are computed by combining the corresponding values
        from the individual event mentions.</li>
        <li>"annotation_id": This optional undocumented attribute should
        never be generated by SERIF under its default configuration.</li>
      </ul>

<p>The <a href="#EventArg">&lt;EventArg&gt;</a> are the entities corresponding to the EventArgMentions,
    with one role listed per argument.  It will either be an entity mention
    or a value mention.</p>


<a name="EventSet"/>
<a name="Event"/>
<a name="EventArg"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#EventSet">EventSet</a>  (<a href="#Event">Event</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#EventSet">EventSet</a>  id                 ID                       #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Event">Event</a>     (<a href="#EventArg">EventArg</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Event">Event</a>     id                 ID                       #IMPLIED
                    event_mention_ids  <a href="#event_mention_ref_list">%event_mention_ref_list;</a> #REQUIRED
                    event_type         CDATA                    #REQUIRED
                    <a href="#genericity">genericity</a>         <a href="#genericity">%genericity;</a>             #REQUIRED
                    <a href="#polarity">polarity</a>           <a href="#polarity">%polarity;</a>               #REQUIRED
                    <a href="#tense">tense</a>              <a href="#tense">%tense;</a>                  #REQUIRED
                    <a href="#modality">modality</a>           <a href="#modality">%modality;</a>               #REQUIRED
                    annotation_id      CDATA                    #IMPLIED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#EventArg">EventArg</a>  EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#EventArg">EventArg</a>  entity_id          <a href="#entity_ref">%entity_ref;</a>             #IMPLIED
                    value_id           <a href="#value_ref">%value_ref;</a>              #IMPLIED
                    role               CDATA                    #REQUIRED&gt;</span></pre>

</div>
<h2>3. A Note on Element Identifiers</h2>


<p>Most SerifXML elements takes an optional "id" attribute, which
     can be used by other elements to point to that element.  For
     example, each entity mention element contains a pointer to a
     start token and an end token, identifying the range of tokens
     that it covers.  By default, Serif will generate simple numerical
     identifiers.  However, the serialization options "verbose_ids"
     and "hierarchical_ids" can be used to tell SERIF to generate more
     informative (if less compact) identifier strings.</p>


<h2>4. Undocumented Elements &amp; Attributes</h2>


<p>______________________ <a href="#Lexicon">&lt;Lexicon&gt;</a> Element ___________________________
     This is used to record lexical items that were used by a version of
     SERIF that does morphological decomposition (such as Arabic).</p>


<a name="Lexicon"/>
<a name="LexicalEntry"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#Lexicon">Lexicon</a>       (<a href="#LexicalEntry">LexicalEntry</a>*)&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#LexicalEntry">LexicalEntry</a>  EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#LexicalEntry">LexicalEntry</a>  id              ID                       #IMPLIED
                        key             CDATA                    #IMPLIED
                        analysis        <a href="#lexical_entry_ref_list">%lexical_entry_ref_list;</a> #IMPLIED
                        category        CDATA                    #IMPLIED
                        voweled_string  CDATA                    #IMPLIED
                        pos             CDATA                    #IMPLIED
                        gloss           CDATA                    #IMPLIED&gt;</span></pre>

<div class="dtd_item">
<h3><a href="#Segments">&lt;Segments&gt;</a> Element</h3>

<p>(This feature is currently undocumented.  Segments will never be
     generated by SERIF in the default configuration.)</p>


<a name="Segments"/>
<a name="Segment"/>
<a name="Attribute"/>
<a name="Field"/>
<a name="Entry"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#Segments">Segments</a>      (<a href="#Segment">Segment</a>*)&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Segment">Segment</a>       (<a href="#Attribute">Attribute</a>*, <a href="#Field">Field</a>*)&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Attribute">Attribute</a>     EMPTY&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Attribute">Attribute</a>     key CDATA #REQUIRED
                        val CDATA #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Field">Field</a>         (<a href="#Entry">Entry</a>*)&gt;</span>
<span class="ATTLIST">&lt;!ATTLIST <a href="#Field">Field</a>         name CDATA #REQUIRED&gt;</span><hr class="ELEMENT"/>
<span class="ELEMENT">&lt;!ELEMENT <a href="#Entry">Entry</a>         (<a href="#Attribute">Attribute</a>*, <a href="#Contents">Contents</a>)&gt;</span></pre>

</div>
<div class="dtd_item">
<h3><a href="#UTCoref">&lt;UTCoref&gt;</a> Element</h3>

<p>This document-level annotation layer records untyped coreference.
    It is currently undocumented.</p>


<a name="UTCoref"/>
<pre class="dtd">
<span class="ELEMENT">&lt;!ELEMENT <a href="#UTCoref">UTCoref</a>       EMPTY&gt;</span></pre>

</div>

</div>
<p class="timestamp">Automatically generated from the DTD on Wed Nov  7 15:31:02 2012</p>
</body>
</html>
