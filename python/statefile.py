# Serif State File Reader
# Copyright 2011 by BBN Technologies Corp.
#
# Author: Edward Loper <eloper@bbn.com>
# State File Version(s) Supported: v1.5
#
"""
Python Support for reading state files that have been generated by Serif.

This module does not (yet) support reading binary files.

The following classes are used to encode the data read from the state
files.  The indentation indicates which objects contain which other
types of objects.  Note that some objects (namely, EntitySet,
ValueMentionSet, and RelMentionSet) are used in two different contexts
-- these objects are marked with [*], and listed twice.

::
 DocTheory ................. Information about a document
   SentenceTheory .......... Information about a single sentence
     TokenSequence ......... The tokens that make up a sentence
       Token ............... A string (symbol) with a start & end offset
     PartOfSpeechSequence .. The part of speech tag sequence for a sentence
       PartOfSpeech ........
     NameTheory ............ The set of named entities in a sentence
       NameSpan ............
     ValueMentionSet [*] ... The set mentions of values in a sentence
       ValueMention ........
     NPChunkTheory ......... The noun phrase chunks in a sentence
       Span ................
     Parse ................. The parse tree for a sentence
       SynNode ............. A node in a parse tree
     MentionSet ............ The set of mentions of entities in a sentence
       Mention .............
     PropositionSet ........ The set of propositions in a sentence
       Proposition .........
         Argument .......... A proposition argument
     EntitySet [*] ......... The set of entities in a sentence
       Entity ..............
     EventMentionSet ....... The set of mentions of events in a sentence
       EventMention ........
     RelMentionSet [*] ..... The set of mentions of relations in a sentence
       RelMention ..........
   EntitySet [*] ........... The set of entities in a document
     Entity ................
   RelationSet ............. The set of relations in a document
     Relation ..............
   EventSet ................ The set of events in a document
     Event .................
   ValueSet ................ The set of values in a document
     Value .................
   RelMentionSet [*] ....... The set of mentions of relations in a document
     RelMention ............
   ValueMentionSet [*] ..... The set of mentions of values in a document
     Mention ...............

In general, these data classes define attributes corresponding to all
of the raw data that is stored in each corresponding Serif class.
However, they may not define methods that match the methods in the
corresponding Serif class.

I.e., these classes allow you to get at all the data that is stored in
the C++ Serif classes, but no attempt was made to replicate the API of
those classes.

Several objects that are represented using custom classes in C++ serif
are encoded using raw values in the Python version.  For example,
Symbol values are just stored as strings.
"""

import re, sys, os, inspect, warnings, struct

class ParseError(ValueError):
    """
    An exception used to indicate that a Serif state file did not
    contain the expected values.  This might indicate that the state
    file is corrupt, or in an incompatible format (e.g., binary
    format).  It also may indicate that the state file is making use
    of some feature that is not (yet) supported by this module.
    """

######################################################################
#{ Document Loader
######################################################################

def load_doc_theory(source, stage=None, verbose=0,
                    skip_sentence_breaks=True):
    """
    Load a document theory from a given source.  This function is
    analagous to the C++ method ``loadDocTheory()`` in
    ``Serif/Generic/driver/DocumentDriver.h``.

    @param source: The source that the document theory should be read
        from; this may be a filename, an open file-like object, or
        a `StateLoader`.
    @param stage: The name of the stage that's being loaded.  If
        specified, then this will be checked against the state file,
        to ensure that it mtaches.
    @param verbose: If nonzero, display messages showing the progress
        of the state loader.  Higher levels give more verbosity.
    @param skip_sentence_breaks: If true, then expect the source to
        begin with a sentence breaks description; and skip over this
        description.
    """
    if isinstance(source, StateLoader):
        state_loader = source
    else:
        state_loader = StateLoader.load(source, verbose)

    if skip_sentence_breaks:
        _skip_sentence_breaks(state_loader)

    if stage: state_description = 'DocTheory following stage: %s' % stage
    else: state_description = None

    state_loader.begin_state_tree(state_description)
    n_sentences = state_loader.load_integer()
    doc_theory = DocTheory(state_loader)
    state_loader.end_state_tree()
    return doc_theory

def load_from_distill_doc(source, num_parts=4, part_num=1):
    # Adapted from Pipeline/IO/DistillDoc.py
    if hasattr(source, 'read'):
        din = source
        filename = getattr(source, 'name', None)
    elif isinstance(source, basestring):
        filename = source
        din = open(source, 'rb')
    else:
        raise ValueError("Bad source type: %r" % source.__class__.__name__)
    intsize = struct.calcsize('<i')
    version_number = struct.unpack('<i', din.read(intsize))
    parts_offsets = [struct.unpack('<i', din.read(intsize))[0] \
                     for i in xrange(num_parts)]
    din.seek(parts_offsets[part_num])
    return load_doc_theory(BinaryStateLoader.load(din))

def _skip_sentence_breaks(state_loader):
    state_loader.begin_state_tree('Sentence breaks: ')
    name = state_loader.load_symbol()
    nsent = state_loader.load_integer()
    state_loader.begin_list('sentence-breaks')
    for i in range(nsent):
        ann_flag = state_loader.load_symbol()
        start = state_loader.load_integer()
        end = state_loader.load_integer()
    state_loader.end_list()
    state_loader.end_state_tree()

######################################################################
#{ State Loader
######################################################################
class StateLoader(object):
    """
    The basic class used to read data from state files.  This class is
    analagous to the C++ class ``Serif/Generic/state/StateLoader.h``,
    and most of the methods it defines correspond directly.

    However, the handling of pointers differs slightly.  In the C++
    serif code, loadPointer() returns an opaque handle, which is then
    replaced by a real pointer during a second pass, using methods
    called resolvePointers().  In this version, loadPointer() will
    always return the requested object itself.  If the requested
    object hasn't been defined yet (i.e., for forward pointers), then
    a pointer to a `Placeholder` object is returned.  When the object
    in question is eventually defined, it is created by transforming
    this placeholder object to the right class.  Thus, there is no
    need for a second pass to re-adjust pointers.
    """
    @staticmethod
    def load(source, verbose=0):
        """
        Create a state loader that loads the given source, which may
        be either a filename or an open stream object.  (To read from
        a string, use a StringIO object.)

        @param verbose: If nonzero, display messages showing the progress
            of the state loader.  Higher levels give more verbosity.
        """
        # Read the source file.  To make life easier for parsing,
        # we just read the whole file at once.
        if hasattr(source, 'read'):
            contents = source.read()
            filename = getattr(source, 'name', None)
        elif isinstance(source, basestring):
            filename = source
            contents = open(source, 'rU').read()
        else:
            raise ValueError("Bad source type: %r" % source.__class__.__name__)

        # Check if it's a binary file.
        if re.match('(\x16\x00|\x16\x00)', contents):
            return BinaryStateLoader(contents, filename, verbose)
        else:
            return TextStateLoader(contents, filename, verbose)

    def __init__(self, filename, verbose=0):
        if self.__class__ is StateLoader:
            raise AssertionError('StateLoader is an abstract base class; '
                                 'use StateLoader.load() to create new '
                                 'StateLoader instances.')

        self._pointers = {0: None}
        self._verbose = verbose
        self._indent = 0 # used if verbose=true for logging messages
        self._filename = filename

    def begin_state_tree(self, state_description=None):
        raise AssertionError('abstract base class')

    def load_string(self):
        raise AssertionError('abstract base class')

    def load_integer(self):
        raise AssertionError('abstract base class')

    def load_unsigned(self): # (not used)
        raise AssertionError('abstract base class')

    def load_real(self):
        raise AssertionError('abstract base class')

    def load_pointer(self):
        raise AssertionError('abstract base class')

    def begin_list(self, expected_name=None, uid_target=None):
        raise AssertionError('abstract base class')

    def end_list(self):
        raise AssertionError('abstract base class')

    def load_specific_string(self, expected_str, message=None):
        s = self.load_string()
        if s != expected_str:
            self._parse_error('Expected %r but got %r' % (expected_str, s))

    def load_symbol(self):
        tok = self.load_string()
        if tok == '<null-symbol>': return None
        else: return tok

    def check_list(self, expected_name=None):
        """Return true if the next item is a list with the given
        expected name.  Do not consume any input, in either case."""
        original_index = self._index
        try:
            try: self.begin_list(expected_name)
            finally: self._index = original_index
            return True
        except ParseError, e:
            return False

    #////////////////////////////////////////////////////////////
    #{ Pointers
    #////////////////////////////////////////////////////////////

    def clear_pointers(self):
        self._pointers = {0: None}

    def register_pointer(self, uid, obj):
        self._pointers[uid] = obj

    def has_placeholder(self, uid=None):
        if uid is None:
            return any(isinstance(v, Placeholder)
                       for v in self._pointers.itervalues())
        else:
            return isinstance(self._pointers.get(uid), Placeholder)

    def get_pointer(self, uid):
        if isinstance(uid, basestring):
            m = re.match('^@(\d+)$', uid)
            if m is None: raise ValueError('Bad bointer %r' % uid)
            uid = int(m.group(1))
        return self._pointers[uid]

    def has_pointer(self, uid):
        return uid in self._pointers

    def new_object(self, cls, uid):
        """
        Return a new object of type `cls`, whose uid is `uid`.  If
        a Placeholder object has been created for `uid`, then this
        new object will be created by changing that Placeholder
        object's __class__.  Otherwise, it will be created by calling
        object.__new__().
        """
        # For the special uid -1, just create the object and return
        # it; don't bother putting it in the pointer table.
        if uid == -1: return object.__new__(cls)

        obj = self._pointers.get(uid, None)

        # If we don't have any value for the uid, then create one, and
        # register it in our pointer table.
        if uid is None or not self.has_pointer(uid):
            obj = object.__new__(cls)
            self._pointers[uid] = obj

        # If we have a placeholder for this UID, then transform that
        # placeholder by changing its class and emptying its instance
        # dictionary.
        elif self.has_placeholder(uid):
            obj = self._pointers[uid]
            obj.__class__ = cls
            obj.__dict__.clear()

        # If we have a non-placeholder value, then complain.
        elif self.has_pointer(uid):
            self._parse_error("Pointer %s redefined!" % uid)

        # Return the new value.
        return obj

    #////////////////////////////////////////////////////////////
    #{ Internal helper methods
    #////////////////////////////////////////////////////////////

    def _parse_error(self, message):
        raise AssertionError('abstract base class')

    SUPPORTED_VERSIONS = ['v1.5']
    def _check_version(self, version):
        if version not in self.SUPPORTED_VERSIONS:
            warnings.warn("Serif state file version %s is not supported;"
                          " trying to read it anyway." % version)

    def _log(self, msg):
        print 'StateLoader:%s%s' % (' '*self._indent, msg)

class Placeholder(object):
    """
    An object that is returned by StateLoader if a pointer is
    requested, but the target of that pointer has not been defined
    yet.  When the object is eventually defined, it is created by
    transforming this placeholder object to the right class.  (This
    bit of magic is performed by Theory.__new__ and
    StateLoader.new_object).
    """
    def __init__(self, pointer):
        self._pointer = pointer
    def __repr__(self):
        return '<Dangling Pointer %s>' % self._pointer

class TextStateLoader(StateLoader):
    def __init__(self, contents, filename, verbose=0):
        StateLoader.__init__(self, filename, verbose)

        # Decode the contents to unicode, if necessary.
        if isinstance(contents, str):
            contents = contents.decode('utf-8')

        # Store our instance variables
        self._contents = contents
        self._index = 0

    _STATE_TREE = re.compile(r'\(Serif-state (v\S+)')
    def begin_state_tree(self, state_description=None):
        version = self._consume(self._STATE_TREE)[0]
        self._check_version(version)
        if state_description:
            self.load_specific_string(state_description)
        else:
            state_description = self.load_string()
        num_objects = self.load_integer()
        if self._verbose:
            self._log('State Tree: %s' % state_description)
            self._indent += 1
            self._log('Serif version: %s' % version)
            self._log('Number of objects: %s' % num_objects)

    _END_STATE_TREE = re.compile('\)')
    def end_state_tree(self):
        self._consume(self._END_STATE_TREE)
        if self._verbose:
            self._indent -= 1

    _STRING = re.compile(r'"([^"]*)"')
    def load_string(self):
        s = self._consume(self._STRING)[0]
        return s.replace(u'\xfffe', '"')

    _INTEGER = re.compile('(-?\d+)')
    def load_integer(self):
        return int(self._consume(self._INTEGER)[0])

    _UNSIGNED = re.compile('(\d+)')
    def load_unsigned(self):
        return int(self._consume(self._UNSIGNED)[0])

    _REAL = re.compile(r'(-?\d*(?:\.?\d*)?(?:e\+\d+)?)')
    def load_real(self):
        return float(self._consume(self._REAL)[0])

    _POINTER = re.compile(r'@(\d+)')
    def load_pointer(self):
        p = int(self._consume(self._POINTER)[0])
        if p not in self._pointers:
            self._pointers[p] = Placeholder(p)
        return self._pointers[p]

    _BEGIN_LIST = re.compile(r"\(([^\s@\(\)]*)(?:@(\d+))?")
    def begin_list(self, expected_name=None, uid_target=None):
        name, uid = self._consume(self._BEGIN_LIST)
        if expected_name is not None and name != expected_name:
            self._parse_error('Expected %r but got %r' % (expected_name, name))
        if uid is not None: uid = int(uid)
        if uid is not None and uid_target is not None:
            self.registerPointer(uid, uid_target)
        if self._verbose:
            if name: self._log(name)
            self._indent += 1
        return uid

    _END_LIST = re.compile('\)')
    def end_list(self):
        self._consume(self._END_LIST)
        if self._verbose:
            self._indent -= 1

    _SKIP_LIST = re.compile(r'([^()"]+|"[^"]*"|[()])')
    def skip_list(self, expected_name):
        self.begin_list(expected_name)
        if self._verbose and expected_name:
            self._log('(skipping)')
        depth = 1
        while depth > 0:
            token = self._consume(self._SKIP_LIST)[0]
            if token == '(': depth += 1
            elif token == ')': depth -= 1
        if self._verbose:
            self._indent -= 1

    #////////////////////////////////////////////////////////////
    #{ Internal helper methods
    #////////////////////////////////////////////////////////////

    _WHITESPACE = re.compile('\s*')
    def _consume(self, regexp):
        # Skip whitespace
        m = self._WHITESPACE.match(self._contents, self._index)
        self._index = m.end()
        # Match the requested regexp
        m = regexp.match(self._contents, self._index)
        if not m:
            valtype = re.sub('^load', '', inspect.stack()[1][3])
            self._parse_error('Expected %s' % valtype)
        self._index = m.end()
        return m.groups()

    def _peek(self, regexp):
        # Skip whitespace
        m = self._WHITESPACE.match(self._contents, self._index)
        # Match the requested regexp.
        m = regexp.match(self._contents, m.end())
        return m

    def _parse_error(self, message, err_prefix='Parse Error'):
        WINDOW = 100
        # Determine the line number.
        lineno = self._contents[:self._index].count('\n') + 1
        # Get the context.
        left = self._contents[max(self._index-WINDOW,0):self._index]
        right = self._contents[self._index:self._index+WINDOW]
        # Restrict the context to a single line
        prevline, left = ('\n'+left).split('\n')[-2:]
        right = right.split('\n')[0]
        context = left+right
        # Generate an error message
        msg = ('\n\n' +
               '%s on line %d: ' % (err_prefix, lineno) +
               '%s\n' % message +
               '%s\n' % ('-'*78) +
               '%s\n' % prevline +
               '%s\n' % context +
               '%s^\n' % (' '*len(left)) +
               '%s\n' % ('-'*78))
        msg = msg.encode('ascii', 'backslashreplace')
        raise ParseError(msg)

    def trace(self):
        try: self._parse_error('', 'Trace')
        except ParseError, e: return str(e)

class BinaryStateLoader(StateLoader):
    BYTE_ORDER = '<' # little-endian

    def __init__(self, contents, filename, verbose=0):
        StateLoader.__init__(self, filename, verbose)
        self._contents = contents
        self._index = 0

    def begin_state_tree(self, state_description=None):
        self.load_specific_string('Serif-state')
        self._check_version(self.load_string())
        if state_description:
            self.load_specific_string(state_description)
        else:
            state_description = self.load_string()
        num_objects = self.load_integer()

    def end_state_tree(self):
        pass

    _UNSIGNED_SHORT_INT = struct.Struct(BYTE_ORDER+'H')
    def load_string(self):
        length = self._consume(self._UNSIGNED_SHORT_INT)[0]
        my_bytes = self._contents[self._index:self._index+length]
        self._index += length
        val = my_bytes.decode('utf-16-le')
        return val

    _SIGNED_INT = struct.Struct(BYTE_ORDER+'i')
    def load_integer(self):
        val = self._consume(self._SIGNED_INT)[0]
        return val

    _UNSIGNED_INT = struct.Struct(BYTE_ORDER+'I')
    def load_unsigned(self): # (not used)
        val = self._consume(self._UNSIGNED_INT)[0]
        return val

    _FLOAT = struct.Struct(BYTE_ORDER+'f')
    def load_real(self):
        val = self._consume(self._FLOAT)[0]
        return val

    def load_pointer(self):
        p = self.load_integer()
        if p not in self._pointers:
            self._pointers[p] = Placeholder(p)
        return self._pointers[p]

    _SPECIAL_BEGIN_LIST_TOKS = {
        'EntitySet':0, 'SynNode':1, 'Token':2, 'PartOfSpeech':3,
        'Argument':4, 'PropositionArgs':5, 'Proposition':6, 'Mention':7}

    def begin_list(self, expected_name=None, uid_target=None):
        self._indent += 1
        if expected_name == '': return

        i = self._SPECIAL_BEGIN_LIST_TOKS.get(expected_name)
        if False: #i is not None:
            if i != self.load_integer():
                self._parse_error('Expected integer %r' % i)
        else:
            got_name = self.load_string()
            if expected_name != got_name:
                self._parse_error('Expected %r, got %r' %
                                  (expected_name, got_name))
            if self._verbose:
                if got_name: self._log(got_name)
        uid = self.load_integer()
        return uid

    def end_list(self):
        self._indent -= 1

    #////////////////////////////////////////////////////////////
    #{ Internal helper methods
    #////////////////////////////////////////////////////////////

    def _consume(self, structobj):
        result = structobj.unpack_from(self._contents, self._index)
        self._index += structobj.size
        return result


    def _parse_error(self, message):
        WINDOW = 100
        # Determine the line number.
        lineno = self._contents[:self._index].count('\n') + 1
        # Get the context.
        left = self._contents[max(self._index-WINDOW,0):self._index]
        right = self._contents[self._index:self._index+WINDOW]
        # Generate an error message
        msg = ('\n\n' +
               'Parse Error on line %d: ' % lineno +
               '%s\n' % message +
               '%s\n' % ('-'*78) +
               '%r\n' % (left+'<*HERE*>'+right) +
               '%s\n' % ('-'*78))
        raise ParseError(msg)

######################################################################
#{ Theory Objects
######################################################################

class TheoryObject(object):
    """
    A base class for objects that form part of a Serif theory
    (such as DocTheory, SentenceTheory, Token, and SynNode).
    Each of these classes corresponds with a Serif class of the
    same name in ``Serif/Generic/theories``.

    The constructors for theory objects all take a single argument,
    a `StateLoader`, and use that `StateLoader` to read the
    contents of the theory object from a state file.

    Subclasses are expected to define the method `_load()`, which
    usually corresponds with a C++ constructor that takes a
    StateLoader as its sole argument.  Before the `load()` method
    is called, the Theory constructor calls StateLoader.begin_list(),
    and uses the result to register the object's pointer address
    in the state loader, if necessary.
    """
    def __new__(cls, state_loader=None):
        # For pickling:
        if state_loader is None:
            return object.__new__(cls)
        # A bit of magic here, to auto-resolve pointers:
        listname = getattr(cls, '_listname', cls.__name__)
        uid = state_loader.begin_list(listname)
        return state_loader.new_object(cls, uid)

    def __init__(self, state_loader):
        self._load(state_loader)
        state_loader.end_list()

    def _load_list(self, state_loader, cls, list_name=None, n=None):
        if n is None: n = state_loader.load_integer()
        if list_name is not None: state_loader.begin_list(list_name)
        values = [cls(state_loader) for i in range(n)]
        if list_name is not None: state_loader.end_list()
        return values

    def __str__(self):
        return self.pprint(depth=1)

    def __repr__(self):
        return '<%s>' % self.__class__.__name__

    def pprint(self, depth=-1, indent='  ', memo=None):
        if memo is None: memo = set()
        if id(self) in memo: return '...'
        memo.add(id(self))
        s = self.__class__.__name__+':'

        # Include both basic attributes, & properties?
        attribs = self.__dict__.keys()
        #attribs += [attr for attr in dir(self.__class__)
        #            if isinstance(getattr(self.__class__, attr), property)
        #            ]

        for attr in sorted(attribs):
            if attr.startswith('_'): continue
            val = getattr(self, attr)
            valstr = self._pprint_value(val, depth, indent, memo)
            s += '\n%s%s = %s' % (indent, attr, valstr)
        return s

    def _pprint_value(self, val, depth, indent, memo):
        if isinstance(val, SynNode):
            return val.treebank_repr(1)
        elif isinstance(val, TheoryObject):
            if depth is not None and depth == 0:
                return '<%s...>' % val.__class__.__name__
            return val.pprint(depth-1, indent+'  ', memo)
        elif isinstance(val, list):
            if len(val) == 0: return '[]'
            if depth is not None and depth == 0: return '[...]'
            items = [self._pprint_value(item, depth-1, indent+'  ', memo)
                     for item in val]
            if not items: return []
            s = '['
            for item in items:
                s += '\n%s  %s' % (indent, item)
            s += '\n%s]' % indent
            return s
        else:
            return repr(val)

class SequenceTheoryObject(TheoryObject):
    """
    Abstract base class for theory objects that act like (immutable)
    sequences.  Subclasses must define the class variable _CHILDREN to
    be the name of the attribute holding the child list.
    """
    def __iter__(self):
        return getattr(self, self._CHILDREN).__iter__()
    def __contains__(self, item):
        return getattr(self, self._CHILDREN).__contains__(item)
    def __getitem__(self, n):
        return getattr(self, self._CHILDREN).__getitem__(n)
    def __repr__(self):
        return '<%s %r>' % (self.__class__.__name__,
                            getattr(self, self._CHILDREN))

class DocTheory(SequenceTheoryObject):
    """@see: ``Serif/Generic/theories/DocTheory.cpp``"""
    _CHILDREN = 'sent_theories'
    def _load(self, state_loader):
        # Sentences
        self.sent_theories = self._load_list(state_loader, SentenceTheory,
                                             'DocTheory::_sentTheories')

        # Other information.
        if state_loader.load_integer():
            self.entity_set = EntitySet(state_loader)
        if state_loader.load_integer():
            self.relation_set = RelationSet(state_loader)
        if state_loader.load_integer():
            self.event_set = EventSet(state_loader)
        if state_loader.load_integer():
            self.document_rel_mention_set = (RelMentionSet(state_loader))
        if state_loader.load_integer():
            self.value_set = ValueSet(state_loader)
        if state_loader.load_integer():
            self.value_mention_set = ValueMentionSet(state_loader)

    def __repr__(self):
        if self.sent_theories:
            docid = self.sent_theories[0].docid
            return '<Document %r>' % docid
        else:
            return '<Empty Document>'

class SentenceTheory(TheoryObject):
    """@see: ``Serif/Generic/theories/SentenceTheory.cpp``"""

    def _subtheories(self):
        # The only reason this is a function rather than a member
        # variable is that these classes haven't been defined yet;
        # and I wanted to keep the theory classes in a top-down
        # order, matching the list in the class docstring.
        return [
            ('token_sequence', TokenSequence),
            ('part_of_speech_sequence', PartOfSpeechSequence),
            ('name_theory', NameTheory),
            ('value_mention_set', ValueMentionSet),
            ('np_chunk_theory', NPChunkTheory),
            ('parse', Parse),
            ('mention_set', MentionSet),
            ('proposition_set', PropositionSet),
            ('entity_set', EntitySet),
            ('rel_mention_set', RelMentionSet),
            ('event_mention_set', EventMentionSet),
            ]

    def _load(self, state_loader, pointers_only=False):
        for (attr, cls) in self._subtheories():
            setattr(self, attr, None)

        if pointers_only:
            # This corresoponds to the SentenceTheory constructor.
            # Oddly enough, it puts docid/pparse in the wrong order.
            # It also uses pointers to subtheories.
            self.docid = state_loader.load_symbol()
            self.pparse = state_loader.load_symbol()
            state_loader.begin_list('SentenceTheory::_subtheories')
            for i, (attr, cls) in enumerate(self._subtheories()):
                assert i == state_loader.load_integer()
                setattr(self, attr, state_loader.load_pointer())
            state_loader.end_list()
        else:
            # This corresponds to the code in
            # DocTheory::loadDocTheory().
            self.pparse = state_loader.load_symbol()
            self.docid = state_loader.load_symbol()
            state_loader.begin_list('SentenceTheory::subtheories')
            for i in range(state_loader.load_integer()):
                subtheory_num = state_loader.load_integer()
                (attr, cls) = self._subtheories()[subtheory_num]
                setattr(self, attr, cls(state_loader))
            state_loader.end_list()

        # Fill in subtheories that weren't initialized w/ None.
        for (attr, cls) in self._subtheories():
            if not hasattr(self, attr):
                setattr(self, attr, None)

        # If we have both a mention set and a proposition set,
        # then provide the proposition arguments with pointers
        # to the mention set.
        if self.mention_set is not None and self.proposition_set is not None:
            for prop in self.proposition_set.props:
                for arg in prop.args:
                    arg._mention_set = self.mention_set

    def __repr__(self):
        if self.token_sequence:
            toks = [tok.symbol for tok in self.token_sequence]
            return '<Sentence: %r>' % (' '.join(toks),)
        else:
            return '<Sentence in %s>' % self.docid

class TokenSequence(SequenceTheoryObject):
    """@see: ``Serif/Generic/theories/TokenSequence.cpp``"""
    _CHILDREN = 'tokens'
    def _load(self, state_loader):
        self.score = state_loader.load_real()
        self.sent_no = state_loader.load_integer()
        n_toks = state_loader.load_integer()
        if state_loader.check_list('TokenSequence::_tokens'):
            # DefaultTokenSequence
            self.tokens = self._load_list(
                state_loader, Token, 'TokenSequence::_tokens', n_toks)
        else:
            # LexicalTokenSequence
            n_orig_toks = state_loader.load_integer()
            self.tokens = self._load_list(
                state_loader, LexicalToken, 'TokenSequence::_tokens', n_toks)
            self.original_tokens = self._load_list(
                state_loader, LexicalToken, 'TokenSequence::_originalTokens',
                n_orig_toks)

class Token(TheoryObject):
    """@see: ``Serif/Generic/theories/Token.cpp``"""
    def _load(self, state_loader):
        self.symbol = state_loader.load_symbol()
        self.start_offset = state_loader.load_integer()
        self.end_offset = state_loader.load_integer()

    def __repr__(self):
        reprstring = '%r' % self.symbol
        if reprstring[0] == 'u': reprstring = reprstring[1:]
        return reprstring

class LexicalToken(TheoryObject):
    """@see: ``Serif/Generic/theories/LexicalToken.cpp``"""
    _listname = 'Token'
    def _load(self, state_loader):
        self.symbol = state_loader.load_symbol()
        self.start_offset = state_loader.load_integer()
        self.end_offset = state_loader.load_integer()
        self.original_token_index = state_loader.load_integer()
        n_lex_entries = state_loader.load_integer()
        self.lex_entries = [state_loader.load_unsigned()
                            for i in range(n_lex_entries)]

    def __repr__(self):
        reprstring = '%r' % self.symbol
        if reprstring[0] == 'u': reprstring = reprstring[1:]
        return reprstring

class PartOfSpeechSequence(SequenceTheoryObject):
    """@see: ``Serif/Generic/theories/PartOfSpeechSequence.cpp``"""
    _CHILDREN = 'tokens'
    _listname = 'POSSequence'
    def _load(self, state_loader):
        self.sent_no = state_loader.load_integer()
        n_tokens = state_loader.load_integer()
        self.score = state_loader.load_real()
        self.tokens = self._load_list(state_loader, PartOfSpeech,
                                      'POSSequence::_pos', n_tokens)

class PartOfSpeech(TheoryObject):
    """@see: ``Serif/Generic/theories/PartOfSpeech.cpp``"""
    def _load(self, state_loader):
        n_pos = state_loader.load_integer()
        self.pos2prob = {}
        for i in range(n_pos):
            pos = state_loader.load_symbol()
            prob = state_loader.load_real()
            self.pos2prob[pos] = prob

    def __repr__(self):
        max_pos = max(self.pos2prob.items(), key=lambda item:item[1])[0]
        return '<%s>' % max_pos

class NameTheory(SequenceTheoryObject):
    """@see: ``Serif/Generic/theories/NameTheory.cpp``"""
    _CHILDREN = 'name_spans'
    def _load(self, state_loader):
        self.score = state_loader.load_real()
        self.name_spans = self._load_list(state_loader, NameSpan,
                                          'NameTheory::nameSpans')

class NameSpan(TheoryObject):
    """@see: ``Serif/Generic/theories/NameSpan.cpp``"""
    def _load(self, state_loader):
        self.start = state_loader.load_integer()
        self.end = state_loader.load_integer()
        self.type = state_loader.load_symbol()

    def __repr__(self):
        return '%s@[%d:%d]' % (self.type, self.start, self.end)

class ValueMentionSet(SequenceTheoryObject):
    """@see: ``Serif/Generic/theories/ValueMentionSet.cpp``"""
    _CHILDREN = 'values'
    def _load(self, state_loader):
        self.values = self._load_list(state_loader, ValueMention,
                                      'ValueMentionSet::_values')

class ValueMention(TheoryObject):
    """@see: ``Serif/Generic/theories/ValueMention.cpp``"""
    def _load(self, state_loader):
        self.uid = state_loader.load_integer()
        self.sent_no = state_loader.load_integer()
        self.start_tok = state_loader.load_integer()
        self.end_tok = state_loader.load_integer()
        self.type = state_loader.load_symbol()

    def __repr__(self):
        return '%s@[%d:%d]' % (self.type, self.start_tok, self.end_tok)

class NPChunkTheory(SequenceTheoryObject):
    """@see: ``Serif/Generic/theories/NPChunkTheory.cpp``"""
    _CHILDREN = 'chunks'
    def _load(self, state_loader):
        self.score = state_loader.load_real()
        self.chunks = self._load_list(state_loader, Span,
                                      'ChunkSpans')
        state_loader.begin_list('NPChunkParse')
        self.parse = Parse(state_loader)
        state_loader.end_list()

class Span(TheoryObject):
    """@see: ``Serif/Generic/theories/Span.cpp``"""
    # n.b.: In the C++ code, Spans are serialized & deserialized by
    # the containing object (NPChunkTheory).
    def _load(self, state_loader):
        self.start_tok = state_loader.load_integer()
        self.end_tok = state_loader.load_integer()
    def __repr__(self):
        return '<Span [%d,%d]>' % self.start_tok, self.end_tok


class Parse(TheoryObject):
    """@see: ``Serif/Generic/theories/Parse.cpp``"""
    def _load(self, state_loader):
        self.score = state_loader.load_real()
        self.root = SynNode(state_loader)
    def __repr__(self):
        return '<Parse %r>' % self.root

class SynNode(SequenceTheoryObject):
    """@see: ``Serif/Generic/theories/SynNode.cpp``"""
    _CHILDREN = 'children'
    def _load(self, state_loader):
        self.id = state_loader.load_integer()
        self.tag = state_loader.load_symbol()
        self.start_tok = state_loader.load_integer()
        self.end_tok = state_loader.load_integer()
        self.mention_index = state_loader.load_integer()
        self.parent = state_loader.load_pointer()
        n_children = state_loader.load_integer()
        self.head_index = state_loader.load_integer()
        self.children = self._load_list(state_loader, SynNode,
                                        '', n_children)

    @property
    def leaves(self):
        if not self.children: return [self.tag]
        else: return sum((child.leaves for child in self), [])

    @property
    def preterminals(self):
        if len(self)==1 and not self[0].children: return [self]
        else: return sum((child.preterminals for child in self), [])

    @property
    def head(self): return self.children[self.head_index]

    # Display syntactic nodes using treebank-like syntax.
    def treebank_repr(self, depth=None):
        tag = self.tag.encode('ascii', 'backslashreplace')
        if not self.children: # terminal (word)
            return '%s' % tag

        if len(self)==1 and len(self[0])==0:
            return '(%s %r)' % (tag, self.children[0])

        if depth is not None and depth <= 0:
            return '(%s ...)' % tag
        else:
            if depth is not None: depth -= 1
            return '(%s %s)' % (tag, ' '.join(c.treebank_repr(depth)
                                              for c in self.children))

    def __repr__(self):
        return self.treebank_repr()

    # Syntactic nodes act like a list of their children:
    def __getitem__(self, item):
        return self.children.__getitem__(item)
    def __len__(self):
        return self.children.__len__()
    def __iter__(self):
        return iter(self.children)

class MentionSet(SequenceTheoryObject):
    """@see: ``Serif/Generic/theories/MentionSet.cpp``"""
    _CHILDREN = 'mentions'
    def _load(self, state_loader):
        self.name_score = state_loader.load_real()
        self.desc_score = state_loader.load_real()
        self.parse = state_loader.load_pointer()
        self.sent_no = state_loader.load_integer()
        self.mentions = self._load_list(state_loader, Mention,
                                        'MentionSet::_mentions')
    def __iter__(self):
        return iter(self.mentions)

class Mention(TheoryObject):
    """@see: ``Serif/Generic/theories/Mention.cpp``"""

    #{ Mention.Type Enumeration
    NONE = 'NONE'; NAME = 'NAME'; PRON = 'PRON'; DESC = 'DESC'
    PART = 'PART'; APPO = 'APPO'; LIST = 'LIST'; INFL = 'INFL'
    Type = (NONE, NAME, PRON, DESC, PART, APPO, LIST, INFL)
    #}

    def _load(self, state_loader):
        self.uid = state_loader.load_integer()
        self.mention_type = self.Type[state_loader.load_integer()]
        self.entity_type = state_loader.load_symbol()
        self.intended_type = state_loader.load_symbol()
        self.is_metonymy_mention = bool(state_loader.load_integer())
        self.entity_subtype = (self.entity_type, state_loader.load_symbol())
        self.role = state_loader.load_symbol()
        self.node = state_loader.load_pointer()
        self.mention_set = state_loader.load_pointer()
        self.parent_index = state_loader.load_integer()
        self.child_index = state_loader.load_integer()
        self.next_index = state_loader.load_integer()
        self.start_char = state_loader.load_integer()
        self.end_char = state_loader.load_integer()

    def __repr__(self):
        return '<%s %r>' % (self.mention_type, ' '.join(self.node.leaves))

class PropositionSet(SequenceTheoryObject):
    """@see: ``Serif/Generic/theories/PropositionSet.cpp``"""
    _CHILDREN = 'props'
    def _load(self, state_loader):
        self.props = self._load_list(state_loader, Proposition,
                                     'PropositionSet::_props')
        self.first_prop_id = state_loader.load_integer()

class Proposition(TheoryObject):
    """@see: ``Serif/Generic/theories/Proposition.cpp``"""

    #{ Proposition.PredType Enumeration
    VERB_PRED = 'VERB_PRED'; COPULA_PRED = 'COPULA_PRED'
    MODIFIER_PRED = 'MODIFIER_PRED'; NOUN_PRED = 'NOUN_PRED'
    POSS_PRED = 'POSS_PRED'; LOC_PRED = 'LOC_PRED'
    SET_PRED = 'SET_PRED'; NAME_PRED = 'NAME_PRED'
    PRONOUN_PRED = 'PRONOUN_PRED'; COMP_PRED = 'COMP_PRED'
    PredType = (VERB_PRED, COPULA_PRED, MODIFIER_PRED,
                NOUN_PRED, POSS_PRED, LOC_PRED, SET_PRED,
                NAME_PRED, PRONOUN_PRED, COMP_PRED)
    #}

    def _load(self, state_loader):
        self.id = state_loader.load_integer()
        self.pred_type = self.PredType[state_loader.load_integer()]
        self.pred_head = state_loader.load_pointer()
        self.particle = state_loader.load_pointer()
        self.adverb = state_loader.load_pointer()
        self.negation = state_loader.load_pointer()
        self.modal = state_loader.load_pointer()
        self.args = self._load_list(state_loader, Argument,
                                    'Proposition::_args')

    def __repr__(self):
        if self.pred_head is None:
            head = self.pred_type
        else:
            head = '-'.join(self.pred_head.leaves)
        args = ', '.join(repr(arg) for arg in self.args)
        #args = ', '.join(repr(arg.mention or '?') for arg in self.args)
        #args = ', '.join('arg%d' % n for n in range(len(self.args)))
        return '%s(%s)' % (head, args)

class Argument(TheoryObject):
    """@see: ``Serif/Generic/theories/Argument.cpp``"""

    #{ Argument.Type Enumeration
    MENTION_ARG = 'MENTION_ARG'; TEXT_ARG = 'TEXT_ARG'
    PROPOSITION_ARG = 'PROPOSITION_ARG'
    Type = (MENTION_ARG, PROPOSITION_ARG, TEXT_ARG)
    #}

    def _load(self, state_loader):
        self.type = self.Type[state_loader.load_integer()]
        self.role_sym = state_loader.load_symbol()
        if self.type == self.MENTION_ARG:
            self.mention_index = state_loader.load_integer()
        elif self.type == self.PROPOSITION_ARG:
            self.prop = state_loader.load_pointer()
        elif self.type == self.TEXT_ARG:
            self.node = state_loader.load_pointer()

    _mention_set = None # set by SentenceTheory._load().

    @property
    def mention(self):
        if getattr(self, 'mention_index', None) is not None:
            return self._mention_set.mentions[self.mention_index]
        else:
            return None

    def __repr__(self):
        if self.type == self.MENTION_ARG:
            return '%r' % ' '.join(self.mention.node.leaves)
        elif self.type == self.PROPOSITION_ARG:
            return '%r' % ' '.join(self.prop.node.leaves)
        elif self.type == self.TEXT_ARG:
            return '<%r>' % ' '.join(self.node.leaves)

class EntitySet(TheoryObject):
    """@see: ``Serif/Generic/theories/EntitySet.cpp``"""
    def _load(self, state_loader):
        self.n_sentences = state_loader.load_integer()
        self.score = state_loader.load_real()
        self.entities = self._load_list(state_loader, Entity,
                                        'EntitySet::_entities')
        self.cur_mention_set = None
        self.prev_mention_sets = []
    def __iter__(self):
        return iter(self.entities)

class Entity(TheoryObject):
    """@see: ``Serif/Generic/theories/Entity.cpp``"""
    def _load(self, state_loader):
        self.id = state_loader.load_integer()
        self.type = state_loader.load_symbol()
        n_mentions = state_loader.load_integer()
        state_loader.begin_list('Entity::mentions')
        self.mentions = [state_loader.load_integer() for i in range(n_mentions)]
        state_loader.end_list()

class EventMentionSet(TheoryObject):
    """@see: ``Serif/Generic/theories/EventMentionSet.cpp``"""
    def _load(self, state_loader):
        self.ementions = self._load_list(state_loader, EventMention,
                                         'EventMentionSet::_ementions')
    def __iter__(self):
        return iter(self.ementions)

class EventMention(TheoryObject):
    """@see: ``Serif/Generic/theories/EventMention.cpp``"""

    def _load(self, state_loader):
        self.uid = state_loader.load_integer()
        self.event_id = state_loader.load_integer()
        self.event_type = state_loader.load_symbol()
        self.anchor_node = state_loader.load_pointer()
        self.anchor_prop = state_loader.load_pointer()
        self.modality = state_loader.load_integer()
        self.genericity = state_loader.load_integer()
        self.tense = state_loader.load_integer()
        self.polarity = state_loader.load_integer()
        self.sent_no = state_loader.load_integer()
        self.score = state_loader.load_real()
        self.arguments = self._load_list(state_loader, EventArgument)
        self.value_arguments = self._load_list(state_loader, EventValueArgument)

#////////////////////////////////////////////////////////////
# { Event Argument Nested Classes
# We do not follow the C++ code in declaring these as nested classes.
# n.b.: These are not a full-fleged theory objects; i.e., in C++,
# they do not define methods for serialization; instead they are
# serialized by the containing object (EventMention).  Therefore,
# they do not inherit from Theory.

class EventArgument(object):
    def __init__(self, state_loader):
        self.role = state_loader.load_symbol()
        self.mention = state_loader.load_pointer()
        self.score = state_loader.load_real()
    def __repr__(self):
        return '<Arg %s>' % self.role

class EventValueArgument(object):
    def __init__(self, state_loader):
        self.role = state_loader.load_symbol()
        self.value_mention = state_loader.load_pointer()
        self.score = state_loader.load_real()
    def __repr__(self):
        return '<ValueArg %s>' % self.role

# }
#////////////////////////////////////////////////////////////

class RelMentionSet(TheoryObject):
    """@see: ``Serif/Generic/theories/RelMentionSet.cpp``"""
    def _load(self, state_loader):
        self.rel_mentions = self._load_list(state_loader, RelMention,
                                            'RelMentionSet::_relations')
    def __iter__(self):
        return iter(self.rel_mentions)

class RelMention(TheoryObject):
    """@see: ``Serif/Generic/theories/RelMention.cpp``"""
    def _load(self, state_loader):
        self.uid = state_loader.load_integer()
        self.type = state_loader.load_symbol()
        self.modality = state_loader.load_integer()
        self.tense = state_loader.load_integer()
        self.lhs = state_loader.load_pointer()
        self.rhs = state_loader.load_pointer()
        self.time_role = state_loader.load_symbol()
        self.time_arg = state_loader.load_pointer()
        self.time_arg_score = state_loader.load_real()
        self.score = state_loader.load_real()

class RelationSet(TheoryObject):
    """@see: ``Serif/Generic/theories/RelationSet.cpp``"""
    def _load(self, state_loader):
        self.relations = self._load_list(state_loader, Relation,
                                         'RelationSet::_relations')
    def __iter__(self):
        return iter(self.relations)

class Relation(TheoryObject):
    """@see: ``Serif/Generic/theories/Relation.cpp``"""
    def _load(self, state_loader):
        self.id = state_loader.load_integer()
        self.type = state_loader.load_symbol()
        self.left_entity_id = state_loader.load_integer()
        self.right_entity_id = state_loader.load_integer()
        self.modality = state_loader.load_integer()
        self.tense = state_loader.load_integer()
        rel_mention_count = state_loader.load_integer()
        state_loader.begin_list('Relation::_relMentions')
        self.rel_mentions = [state_loader.load_pointer()
                             for i in range(rel_mention_count)]
        state_loader.end_list()

class EventSet(TheoryObject):
    """@see: ``Serif/Generic/theories/EventSet.cpp``"""
    def _load(self, state_loader):
        self.events = self._load_list(state_loader, Event,
                                      'EventSet::_events')
    def __iter__(self):
        return iter(self.events)

class Event(TheoryObject):
    """@see: ``Serif/Generic/theories/Event.cpp``"""
    def _load(self, state_loader):
        self.id = state_loader.load_integer()
        self.type = state_loader.load_symbol()
        self.modality = state_loader.load_integer()
        self.tense = state_loader.load_integer()
        self.polarity = state_loader.load_integer()
        self.genericity = state_loader.load_integer()
        n_mentions = state_loader.load_integer()
        state_loader.begin_list('Event::_eventMentions')
        self.event_mentions = [state_loader.load_pointer()
                               for i in range(n_mentions)]
        state_loader.end_list()

class ValueSet(TheoryObject):
    """@see: ``Serif/Generic/theories/ValueSet.cpp``"""
    def _load(self, state_loader):
        self.values = self._load_list(state_loader, Value,
                                      'ValueSet::_values')
    def __iter__(self):
        return iter(self.values)

class Value(TheoryObject):
    """@see: ``Serif/Generic/theories/Value.cpp``"""
    def _load(self, state_loader):
        self.id = state_loader.load_integer()
        self.type = state_loader.load_symbol()
        self.timex_val = state_loader.load_symbol()
        self.timex_anchor_val = state_loader.load_symbol()
        self.timex_anchor_dir = state_loader.load_symbol()
        self.timex_set = state_loader.load_symbol()
        self.timex_mod = state_loader.load_symbol()
        self.timex_non_specific = state_loader.load_symbol()
        self.val_mention = state_loader.load_pointer()

######################################################################
# Test
######################################################################

def test(filename = './test/XIN20041004.0077-state-16-doc-values'):
    d = load_doc_theory(filename)
    print d
    return d


if __name__  == '__main__':
    d = test()
